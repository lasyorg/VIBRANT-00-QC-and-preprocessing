---
title: "qPCR daily data QC"
author: Laura Symul & Laura Vermeren 
date: today
format: 
   html:
     page-layout: full
     code-fold: true
     toc: true
     toc-location: left
     toc-depth: 5
     embed-resources: true
execute:
  cache: refresh # true refresh false
  warning: false
knitr:
  opts_chunk:
    out.width: "100%"
editor: source
---


```{r}
#| warning: false
#| cache: false

library(tidyverse)
library(magrittr)
library(gt)
library(patchwork)
library(SummarizedExperiment)
library(tidySummarizedExperiment)

tmp <- fs::dir_map("R scripts/", source)
tmp <- fs::dir_map("../VIBRANT-99-utils/R/", source)
rm(tmp)

theme_set(theme_light())

```

This document presents the QC and data preparation steps performed on the **daily** qPCR data for the 15 LBP strains and total 16S rRNA gene quantification. It is mostly inspired from the code developed in the `03_qPCR.Qmd` script which pertained to the qPCR data performed on the "weekly swabs" (*i.e.*, the swabs collected at the weekly in-clinic visits) while here, the qPCR data were generated on the "daily swabs, (*i.e.*, swabs collected daily at home).


:::callout-important
This data was generated in summer 2025, *after* the arm unblinding. While the assay was performed by technicians not otherwise involved in the study, and while the data preparation code this code was developed exclusively using blinded data, we cannot fully exclude that some steps were subconsciously influenced by knowledge of the unblinded data.
:::



## Loading and cleaning the data

```{r}

qpcr_dir <- str_c(dropbox_dir(), "14_VIBRANT qPCR/20250818/")
file <- "VIBRANT_qPCR_data_merged_081825.csv"
cat("We load the file", file, " (15 LBP strains + total 16S rRNA)\n\n")
qpcr <- read_csv(str_c(qpcr_dir, file))

rm(qpcr_dir, file)

```


The data is provided in long format:

```{r}

qpcr |> glimpse()

```

```{r}
#| eval: false

qpcr$Data_row |> unique() |> length()
nrow(qpcr)

qpcr$Well |> table()
qpcr$Well |> range()

qpcr$Fluor |> table()

qpcr$Content |> table()

qpcr$Replicate |> table()

qpcr |> dplyr::count(Content, Replicate)

qpcr |> dplyr::count(Replicate, plate_id, VMRC_Group, Target)


qpcr$Sample |> table(useNA = "ifany")

qpcr |> dplyr::count(Well, Sample)

qpcr |> dplyr::count(Content, Sample)

qpcr$plate_id |> table()
qpcr$Plate_number |> table()
qpcr |> dplyr::count(plate_id, Plate_number)

qpcr$gDNA_Plate_ID |> table()

qpcr |> dplyr::count(plate_id, Plate_number, gDNA_Plate_ID)
# TODO: document this in the report (que chaque gDNA plate sent by Synaye was put on a single qPCR plate)


qpcr$VMRC_Group |> table(useNA = "ifany")

qpcr |> dplyr::count(plate_id, VMRC_Group)
# Maybe document that all samples from the same gDNA box were put on the same qPCR plate BUT that the plate_id are not unique because they had to split the gDNA box samples to 6 plates: 5 for the LBPs and 1 for the total 16S.

qpcr$InRedos |> table(useNA = "ifany") # All NA -> remove

qpcr$Dilution_Factor |> unique()

```




```{r}

dictionary <- 
  tibble(original_name = colnames(qpcr)) |> 
  mutate(
    description = 
      case_when(
        (original_name == "Data_row") ~ 'Table row number (1 number per row)',
        (original_name == "Well") ~ str_c("qPCR plate well ID. From ", min(qpcr$Well), " to ", max(qpcr$Well), " (",qpcr$Well |> unique() |> length()," unique wells in total)"),
        (original_name == "Fluor") ~ str_c('fluorescent dye used (one of ', qpcr$Fluor |> unique() |> str_c(collapse = ", "), ")"),
        (original_name == "Content") ~ 'Indicates whether well is empty, contains a clinical sample, a standard, or a negative control.',
        (original_name == "Replicate") ~ 
          str_c(
            "A number identifying replicates of the same sample, ranging from ", min(qpcr$Replicate, na.rm = TRUE), " to ", max(qpcr$Replicate, na.rm = TRUE), 
            " (with ", sum(is.na(qpcr$Replicate)), " missing values). Values are repeated 495, or 990 times, but typically 3 (or 6) time per plate (it can be 6 because standards are numbered from 1 to 7, and samples are also numbered from 1 to N)."
          ),
        (original_name == "Sample") ~ 'A qPCR plate-specific sample ID. This column wont be used or kept for downstream analyses.',
        (original_name == "Cq") ~ 'Quantification cycle (Cq) value.',
        (original_name == "Starting Quantity (SQ)") ~ 'Starting quantity (SQ) value; computed from the Cq values using the inverse calibration function (calibration curve fitted using the expected SQ values for the standards).',
        (original_name == "Cq Mean") ~ 'Mean across replicates',
        (original_name == "plate_id") ~ str_c('qPCR plate name - several qPCR plates have the same name because they have been named according to the gDNA boxes and qPCR plates for the same sample but different targets have the same `plate_id`; there are ', qpcr$plate_id |> unique() |> length()," unique plate IDs in total."),
        (original_name == "Plate_number") ~ str_c("The extraction plate number; there are ", qpcr$Plate_number |> unique() |> length()," unique plate numbers in total (5 identical `plate_id` per `Plate_number`)."),
        (original_name == "gDNA_Plate_ID") ~ 'The extraction plate ID',
        (original_name == "VMRC_Group") ~ str_c('The group of the LBP strains. There are ', qpcr$VMRC_Group |> unique() |> na.omit() |> length()," unique VMRC groups in total (", qpcr$VMRC_Group |> unique() |> na.omit() |> sort() |> str_c(collapse = ", "), ")"),
        (original_name == "Group_Fluor") ~ 'Concatenation of the `VMRC_Group` and `Fluor` columns',
        (original_name == "Target") ~ str_c('The target "gene" (here taxa/strain). There are ', qpcr$Target |> unique() |> length(), " unique targets in total (", qpcr$Target |> unique() |> str_c(collapse = ", "),")"),
        (original_name == "target_type") ~ "Whether the target is a LBP strain or the 16S rRNA gene target",
        (original_name == "gDNA_Plate_Well") ~ str_c('The concatenation of the gDNA plate ID and the plate well; there are ', qpcr$gDNA_Plate_Well |> unique() |> length()," unique gDNA plate wells in total in the format `[gDNA_Plate_ID]_[Well]` (e.g., ", qpcr$gDNA_Plate_Well |> unique() |> magrittr::extract(10),")"),
        (original_name == "VIBR_Sample_ID") ~ str_c("VIBRANT sample ID; there are ", qpcr$VIBR_Sample_ID |> unique() |> length(), " unique VIBRANT sample IDs in total)"),
        (original_name == "Dilution_Factor") ~ str_c('The qPCR plate specific dilution factor. There are ', qpcr$Dilution_Factor |> unique() |> length()," unique dilution factors in total (", qpcr$Dilution_Factor |> unique()  |> sort() |> str_c(collapse = ", "),")"),
        (original_name == "Quant_Adjusted") ~ str_c("Quantification value adjusted by the dilution factor; range from ", min(qpcr$Quant_Adjusted, na.rm = TRUE)," to ", max(qpcr$Quant_Adjusted, na.rm = TRUE)),
        (original_name == "Copies_per_swab") ~ str_c("The number of target copies per swab, computed from the adjusted quantification values. Ranges from ", min(qpcr$Copies_per_swab, na.rm = TRUE)," to ", max(qpcr$Copies_per_swab, na.rm = TRUE)),
         (original_name == "InRedos") ~ str_c("Whether the sample was part of the samples that were redone (= re-extracted) - in this data, no samples were re-extracted, so this column has `NA` for all rows."),
        TRUE ~ "????"
      )
  )

```

```{r}
# dictionary |> gt()
```




### Tidy names

We tidy the column names for consistency and readability.

```{r}

qpcr <- qpcr |> janitor::clean_names()
qpcr <- qpcr |> 
  dplyr::rename(
    strain_group_qpcr = vmrc_group,
    starting_quantity = starting_quantity_sq,
    pcr_plate_id = plate_id,
    ext_lib_plate_nb = plate_number,
    ext_lib_plate_id = g_dna_plate_id,
    ext_lib_position = g_dna_plate_well
  )

```

```{r}
dictionary <- 
  dictionary |> 
  mutate(name = colnames(qpcr)) |> 
  select(name, everything())
```


The new column names are:

```{r}

dictionary |> 
  gt() |> 
  cols_label(
    name = "New column name",
    original_name = "Original column name",
    description = "Description"
  ) 

```

```{r}

qpcr <- qpcr |> select(-any_of("in_redos"))

```

We noticed a typo in `ext_lib_position`: all samples are labelled as the concatenation of the `ext_lib_plate_id` and their well coordinates where the well row is a big letter, but a few sample were labelled "`_h9`" instead of "`_H9`". We fix this here.

```{r}

qpcr <- 
  qpcr |> 
  mutate(ext_lib_position = str_replace(ext_lib_position, "_h9$", "_H9"))

# qpcr$ext_lib_position |> str_remove("[0-9]*_") |> str_remove("MGH8_") |> table()

```


```{r}

qpcr <- 
  qpcr |> 
  arrange(strain_group_qpcr, target) |> 
  mutate(
    target = target |> fct_inorder()
  )

```



```{r}
qpcr <- 
  qpcr |> 
  mutate(
    well_col = well |> str_sub(1, 1), 
    well_row = well |> str_sub(2,3) |> as.integer()
    ) |> 
  relocate(well_col, well_row, .after = well)
```




### qPCR targets

#### Target's plate layout and fluorescent probes


The plate x Fluorescence x Target layout is as follows:

```{r}
#| fig-width: 13
#| fig-height: 5.5

qpcr |> 
  dplyr::count(fluor, target, strain_group_qpcr, pcr_plate_id, ext_lib_plate_nb) |> 
  arrange(ext_lib_plate_nb, strain_group_qpcr, pcr_plate_id, fluor) |> 
  mutate(
    target = target |> fct_inorder(), 
    plate_nb = str_c("ext. plate: ", ext_lib_plate_nb) |> fct_inorder(),
    pcr_plate_id = pcr_plate_id |> fct_inorder()
    ) |> 
  ggplot() +
  aes(
    x = pcr_plate_id,
    y = target |> factor() |> fct_rev(),
    fill = fluor
  ) +
  geom_tile() +
  facet_grid(strain_group_qpcr ~ plate_nb, scales = "free", space = "free") +
  xlab("qPCR plate ID") +
  ylab("Target") +
  scale_fill_manual(
    name = "Fluor.",
    values = c("FAM" = "dodgerblue1", "HEX" = "green3", "Cy5" = "#F8766D", "SYBR" = "green")
  ) +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.title.x = element_text(margin = margin(t = -20)),
    strip.text.y = element_text(angle = 0),
    strip.text.x = element_text(angle = 90)
  )

```

For each extraction plates, there are 5 qPCR plates for the 5 LBP strain groups (VMRC_1 to VMRC_5) and 1 plate for the total 16S rRNA gene quantification with the same name (e.g., Box 01 Daily). 

Potential batch effects due to extraction should be checked for `ext_lib_plate_id` and those due to the qPCR itself using the `pcr_plate_id`.

#### LBP strain information

We add the LBP strain information to the qPCR data.

```{r}

SE_mg <-
  readRDS(
    list.files(
      path = get_01_output_dir(),
      pattern = "02_se_mg_.*\\.rds$", full.names = TRUE
    ) |>
      sort(decreasing = TRUE) |>
      magrittr::extract(1)
  )

qpcr <- 
  qpcr |> 
  dplyr::left_join(
    SE_mg |>
      rowData() |> as.data.frame() |> as_tibble() |> 
      dplyr::filter(!is.na(LBP)) |> 
      select(taxon_id, taxon_label, LBP, strain_id, strain_origin, biose_id) |> 
      dplyr::rename(target = taxon_id),
    by = join_by(target)
  )

```

```{r}

qpcr <- 
  qpcr |> 
  mutate(taxon_label = taxon_label |> str_replace_na("16S rRNA gene target"))

```


```{r}
rm(SE_mg)
```

```{r}
#| fig-height: 2.5
#| fig-width: 7

qpcr |> 
  arrange(strain_group_qpcr, strain_origin) |>
  mutate(target = target |> fct_inorder()) |> 
  ggplot() +
  aes(x = target, y = strain_group_qpcr, col = strain_group_qpcr) +
  geom_point() +
  facet_grid(. ~ LBP + strain_origin, scales = "free", space = "free")  +
  xlab("Target") + ylab("VMRC group") +
  guides(col = "none") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  ) 

```

```{r}

qpcr <- 
  qpcr |> 
  mutate(
    target_type = 
      case_when(
        target == "16S" ~ "16S rRNA gene",
        TRUE ~ "LBP strain"
      )
  )
  
```




### Sample types and plate layout

In this section, we define a `qpcr_sample_type` variable to define the type of sample (Standard, Water, Negative Controls, Clinical sample, etc.) that was placed in each well. To construct this variable, we use information found in the `content`, `sample`, and `vibr_sample_id` columns.

#### `content` and plate layout


```{r}
#| fig-width: 30
#| fig-height: 8

qpcr |> 
  select(well_col, well_row, content, replicate, ext_lib_plate_nb, pcr_plate_id, target_type, strain_group_qpcr) |>
  distinct() |> 
  ggplot() +
  aes(x = well_row |> factor(), y = well_col |> factor() |> fct_rev(), fill = content) +
  facet_grid(target_type + strain_group_qpcr ~ pcr_plate_id) +
  geom_tile() +
  scale_fill_discrete(guide = guide_legend(nrow = 4)) +
  xlab("Well column") + ylab("Well row") +
  theme(
    legend.position = "bottom",
    legend.direction = "horizontal"
  )


```

The plate layout appears to be the same for all extraction plates for the LBP strains, but different for the 16S plates and we notice 4 "family" of `content`: "Neg Ctrl", "NTC", "Std-[0-7]", and wells labelled as "Unkn-[0-9]*":


```{r}
#| fig-width: 13
#| fig-height: 10

qpcr |> 
  select(well_col, well_row, content, replicate, ext_lib_plate_nb, pcr_plate_id, target_type, strain_group_qpcr) |>
  distinct() |> 
  mutate(
    content_simpl = content |> str_remove("-[0-9]*")
  ) |> 
  filter(pcr_plate_id %in% c("Box 01 Daily", "Box 02 Daily", "MGH Home 1", "MGH Home 8 + Repeats")) |>
  ggplot() +
  aes(x = well_row |> factor(), y = well_col |> factor() |> fct_rev(), fill = content_simpl) +
  facet_grid(target_type + strain_group_qpcr ~ pcr_plate_id) +
  geom_tile() +
  scale_fill_discrete(guide = guide_legend(nrow = 1)) +
  xlab("Well column") + ylab("Well row") +
  theme(
    legend.position = "bottom"
  )

```

Overlaying the `replicate` structure:



```{r}
#| fig-width: 13
#| fig-height: 10

qpcr |> 
  select(well_col, well_row, content, sample, replicate, ext_lib_plate_nb, pcr_plate_id, target_type, strain_group_qpcr) |>
  distinct() |> 
  mutate(
    content_simpl = content |> str_remove("-[0-9]*"),
    group = str_c(content_simpl, sample)
  ) |> 
  filter(pcr_plate_id %in% c("Box 01 Daily", "Box 02 Daily", "MGH Home 1", "MGH Home 8 + Repeats")) |>
  ggplot() +
  aes(x = well_row |> factor(), y = well_col |> factor() |> fct_rev(), fill = content_simpl) +
  facet_grid(target_type + strain_group_qpcr ~ pcr_plate_id) +
  geom_tile() +
  geom_line(aes(group = group)) +
  scale_fill_discrete(guide = guide_legend(nrow = 1)) +
  xlab("Well column") + ylab("Well row") +
  theme(
    legend.position = "bottom"
  )

```

For the LBP strain plates, triplicates are placed next to each other. For the 16S plates, the biological samples triplicates are placed in "triangles".



#### `sample` and plate layout

```{r}
#| fig-width: 13
#| fig-height: 10

qpcr |> 
  select(well_col, well_row, content, sample, replicate, ext_lib_plate_nb, pcr_plate_id, target_type, strain_group_qpcr) |>
  distinct() |>  
  filter(pcr_plate_id %in% c("Box 01 Daily", "Box 02 Daily", "MGH Home 1", "MGH Home 8 + Repeats")) |>
  ggplot() +
  aes(x = well_row |> factor(), y = well_col |> factor() |> fct_rev(), fill = sample) +
  facet_grid(target_type + strain_group_qpcr ~ pcr_plate_id) +
  geom_tile() +
  geom_line(aes(group = sample), alpha = 0.5) +
  scale_fill_discrete(guide = guide_legend(nrow = 6)) +
  xlab("Well column") + ylab("Well row") +
  labs(
    caption = "Lines connect wells with the same `sample` id."
  ) +
  theme(
    legend.position = "bottom"
  )

```

Some samples appear to be water - so can likely retrieve that information from the `sample` column to build the `sample_type` column.

```{r}
#| fig-width: 13
#| fig-height: 10

qpcr |> 
  select(well_col, well_row, content, sample, replicate, ext_lib_plate_nb, pcr_plate_id, target_type, strain_group_qpcr) |>
  distinct() |>  
  filter(pcr_plate_id %in% c("Box 01 Daily", "Box 02 Daily", "MGH Home 1", "MGH Home 8 + Repeats")) |>
  ggplot() +
  aes(x = well_row |> factor(), y = well_col |> factor() |> fct_rev(), fill = str_detect(sample, "water")) +
  facet_grid(target_type + strain_group_qpcr ~ pcr_plate_id) +
  geom_tile() +
  scale_fill_discrete(guide = guide_legend(nrow = 1)) +
  xlab("Well column") + ylab("Well row") +
  theme(
    legend.position = "bottom"
  )

```
#### `vibr_sample_id` and plate layout

```{r}
#| eval: false
#| fig-width: 30
#| fig-height: 8

qpcr |> 
   mutate(
    has_a_vibrant_sample_id = !is.na(vibr_sample_id),
    has_a_ext_lib_position = !is.na(ext_lib_position)
  ) |> 
  select(well_col, well_row, has_a_vibrant_sample_id, has_a_ext_lib_position, ext_lib_plate_nb, pcr_plate_id, target_type, strain_group_qpcr) |>
  distinct() |> 
  ggplot() +
  aes(x = well_row |> factor(), y = well_col |> factor() |> fct_rev(), fill = has_a_vibrant_sample_id) +
  facet_grid(target_type + strain_group_qpcr ~ pcr_plate_id) +
  geom_tile() +
  # geom_point(aes(alpha = has_a_ext_lib_position), size = 0.5) +
  scale_fill_discrete(guide = guide_legend(nrow = 1)) +
  xlab("Well column") + ylab("Well row") +
  theme(
    legend.position = "bottom",
    legend.direction = "horizontal"
  )


```


```{r}
#| fig-width: 15
#| fig-height: 4.5

qpcr |> 
   mutate(
    has_a_vibrant_sample_id = !is.na(vibr_sample_id),
    has_a_ext_lib_position = !is.na(ext_lib_position)
  ) |> 
  select(well_col, well_row, has_a_vibrant_sample_id, has_a_ext_lib_position, ext_lib_plate_nb, pcr_plate_id, target_type, strain_group_qpcr) |>
  distinct() |> 
  ggplot() +
  aes(x = well_row |> factor(), y = well_col |> factor() |> fct_rev(), fill = has_a_vibrant_sample_id) +
  facet_grid(target_type + strain_group_qpcr ~ pcr_plate_id) +
  geom_tile() +
  # geom_point(aes(alpha = has_a_ext_lib_position), size = 0.5) +
  scale_fill_discrete(guide = guide_legend(nrow = 1)) +
  xlab("Well column") + ylab("Well row") +
  theme(
    axis.text = element_blank(),
    strip.text.x = element_text(angle = 90),
    strip.text.y = element_text(angle = 0),
    legend.position = "bottom",
    legend.direction = "horizontal"
  )


```



We see that for some plates, the `vibr_sample_id` () is missing for all wells, while for other plates, it is present for most wells. 


If we can confirm that the plate layout is the same across LBP strain plates, then, we can likely assume that this was simply a mistake in reporting the `vibr_sample_id` for some plates, and we can propagate the `vibr_sample_id` from one plate to another.

We check that this is true for all plates where the `vibr_sample_id` is available by checking that each `vibr_sample_id` has the same set of wells across plates:

```{r}


qpcr |> 
  filter(!is.na(vibr_sample_id), target_type == "LBP strain") |> 
  select(vibr_sample_id, strain_group_qpcr, pcr_plate_id,  well) |> 
  distinct() |> 
  mutate(position = str_c(pcr_plate_id, " ", well)) |> 
  arrange(vibr_sample_id, strain_group_qpcr, position) |>
  group_by(vibr_sample_id, strain_group_qpcr) |>
  summarize(positions = str_c(position, collapse = ", "), n_positions = n(), .groups = "drop_last") |> 
  summarize(
    n_distinct_positions = positions |> unique() |> length(), 
    n_LBP_plates = n(),
    positions = str_c(positions |> unique(), collapse = " | "), 
    n_positions = str_c(n_positions |> unique(), collapse = " | "), 
    .groups = "drop"
    ) |>
  dplyr::count(n_LBP_plates, n_distinct_positions, name = "n_samples") |>  # n_positions, 
  gt("Number of distinct positions (box & well) across qPCR plates (LBP strain group) per VIBRANT sample ID.")


```

We see that all samples have the exact same locations across plates, so we assume that we can propagate the `vibr_sample_id` across plates.

:::callout-important
@Michael: can you confirm that this is a safe assumption?

â†’ Michael confirmed orally during a Teams meeting.
:::

We thus create a dictionary of the positions (`pcr_plate_id` and `well`) for each "`vibr_sample_id`" based on the plates where the `vibr_sample_id` was available, and then use this dictionary to fill in the missing `vibr_sample_id` values.


```{r}

vibrant_sample_id_dict <- 
  qpcr |> 
  filter(!is.na(vibr_sample_id), target_type == "LBP strain") |> 
  select(vibr_sample_id, target_type, pcr_plate_id,  well) |> 
  distinct() |> 
  dplyr::rename(vibr_sample_id_new = vibr_sample_id)

```


```{r}


qpcr <- 
  qpcr |> 
  mutate(vibr_sample_id_original = vibr_sample_id) |>
  select(-any_of("vibr_sample_id_new")) |>
  left_join(
   vibrant_sample_id_dict, 
   by = join_by(target_type, pcr_plate_id, well)
  ) 


# qpcr |> 
#   filter(
#     (is.na(vibr_sample_id) & !is.na(vibr_sample_id_new)) |
#       (vibr_sample_id_new != vibr_sample_id)
#     ) |> 
#   select(target_type, ext_lib_plate_id, ext_lib_position, vibr_sample_id, vibr_sample_id_new) |> 
#   distinct() |> 
#   View()


qpcr |>
  filter(
    (is.na(vibr_sample_id) & !is.na(vibr_sample_id_new)) |
      (vibr_sample_id_new != vibr_sample_id)
    ) |>
  select(vibr_sample_id) |>
  distinct() |> 
  is.na() |> 
  all()

```


```{r}
#| fig-width: 15
#| fig-height: 5

qpcr |> 
   mutate(
    has_a_vibrant_sample_id = !is.na(vibr_sample_id),
    has_a_ext_lib_position = !is.na(ext_lib_position)
  ) |> 
  select(well_col, well_row, has_a_vibrant_sample_id, has_a_ext_lib_position, ext_lib_plate_nb, pcr_plate_id, target_type, strain_group_qpcr) |>
  distinct() |> 
  ggplot() +
  aes(x = well_row |> factor(), y = well_col |> factor() |> fct_rev(), fill = has_a_vibrant_sample_id) +
  facet_grid(target_type + strain_group_qpcr ~ pcr_plate_id) +
  geom_tile() +
  # geom_point(aes(alpha = has_a_ext_lib_position), size = 0.5) +
  scale_fill_discrete(guide = guide_legend(nrow = 1)) +
  xlab("Well column") + ylab("Well row") +
  ggtitle("BEFORE FIXING") +
  theme(
    axis.text = element_blank(),
    strip.text.x = element_text(angle = 90),
    strip.text.y = element_text(angle = 0),
    legend.position = "bottom",
    legend.direction = "horizontal"
  )
  
  
qpcr |> 
   mutate(
    has_a_vibrant_sample_id = !is.na(vibr_sample_id_new),
    has_a_ext_lib_position = !is.na(ext_lib_position)
  ) |> 
  select(well_col, well_row, has_a_vibrant_sample_id, has_a_ext_lib_position, ext_lib_plate_nb, pcr_plate_id, target_type, strain_group_qpcr) |>
  distinct() |> 
  ggplot() +
  aes(x = well_row |> factor(), y = well_col |> factor() |> fct_rev(), fill = has_a_vibrant_sample_id) +
  facet_grid(target_type + strain_group_qpcr ~ pcr_plate_id) +
  geom_tile() +
  # geom_point(aes(alpha = has_a_ext_lib_position), size = 0.5) +
  scale_fill_discrete(guide = guide_legend(nrow = 1)) +
  xlab("Well column") + ylab("Well row") +
  ggtitle("AFTER FIXING") +
  theme(
    axis.text = element_blank(),
    strip.text.x = element_text(angle = 90),
    strip.text.y = element_text(angle = 0),
    legend.position = "bottom",
    legend.direction = "horizontal"
  )


```



```{r}
qpcr <- 
  qpcr |> 
  mutate(
    vibr_sample_id = 
      case_when(
        !is.na(vibr_sample_id) ~ vibr_sample_id,
        is.na(vibr_sample_id) & !is.na(vibr_sample_id_new) ~ vibr_sample_id_new,
        TRUE ~ NA_character_
      )
  ) |> 
  select(-vibr_sample_id_new)


```




While this is fixed, we note, however, that some wells have the `ext_lib_position` (the position in the extraction library plate) missing - and sadly, the pattern of missingness was not the same as the one for the `vibr_sample_id`. 

```{r}
#| fig-width: 15
#| fig-height: 4.5

qpcr |> 
   mutate(
    has_a_vibrant_sample_id = !is.na(vibr_sample_id),
    has_a_ext_lib_position = !is.na(ext_lib_position)
  ) |> 
  select(well_col, well_row, has_a_vibrant_sample_id, has_a_ext_lib_position, ext_lib_plate_nb, pcr_plate_id, target_type, strain_group_qpcr) |>
  distinct() |> 
  ggplot() +
  aes(x = well_row |> factor(), y = well_col |> factor() |> fct_rev(), fill = has_a_vibrant_sample_id) +
  facet_grid(target_type + strain_group_qpcr ~ pcr_plate_id) +
  geom_tile() +
  geom_point(aes(alpha = has_a_ext_lib_position), size = 0.5) +
  scale_fill_discrete(guide = guide_legend(nrow = 1)) +
  xlab("Well column") + ylab("Well row") +
  theme(
    axis.text = element_blank(),
    strip.text.x = element_text(angle = 90),
    strip.text.y = element_text(angle = 0),
    legend.position = "bottom",
    legend.direction = "horizontal"
  )


```

It may still be the same explanation (the the info from the original manifest was not copied for all plates), so we also check that for each `vibr_sample_id`, the `ext_lib_position` is the same across plates:

```{r}

tmp <- 
  qpcr |> 
  filter(!is.na(vibr_sample_id), !is.na(ext_lib_position), target_type == "LBP strain") |> 
  select(vibr_sample_id, strain_group_qpcr, pcr_plate_id,  ext_lib_position) |> 
  distinct() |> 
  arrange(vibr_sample_id, strain_group_qpcr, ext_lib_position) |>
  group_by(vibr_sample_id, strain_group_qpcr) |>
  summarize(
    ext_lib_positions = str_c(ext_lib_position, collapse = ", "), 
    n_positions = n(), 
    .groups = "drop_last"
    ) |> 
  arrange(-n_positions) |> 
  summarize(
    n_distinct_ext_lib_positions = ext_lib_positions |> unique() |> length(), 
    n_LBP_plates = n(),
    ext_lib_positions = str_c(ext_lib_positions |> unique(), collapse = " | "), 
    n_positions = str_c(n_positions |> unique(), collapse = " | "), 
    .groups = "drop"
    ) 

tmp |>
  dplyr::count(n_LBP_plates, n_distinct_ext_lib_positions, n_positions, name = "n_samples") |>  # n_positions, 
  gt(caption = "Number of distinct positions (ext_lib_position) across qPCR plates (LBP strain group) per VIBRANT sample ID.")

```


Reassuringly, all VIBRANT sample ID have the same `ext_lib_position` when it is available. 


From the visualization above, we also note that some wells have non-missing `ext_lib_position` but missing `vibr_sample_id` - these may be potential controls.

Since we may be able to retrieve the control type from the manifest of the daily 16S rRNA sequencing data, we check that `ext_lib_position` are placed in the same wells across plates and if so, propagate the `ext_lib_position` across plates. 


```{r}

tmp <- 
  qpcr |> 
  filter(!is.na(ext_lib_position), target_type == "LBP strain") |> 
  select(ext_lib_position, strain_group_qpcr, pcr_plate_id, well) |>
  mutate(pcr_position = str_c(pcr_plate_id, " ", well)) |>
  distinct() |> 
  arrange(ext_lib_position, strain_group_qpcr, pcr_position) |>
  group_by(ext_lib_position, strain_group_qpcr) |>
  summarize(
    pcr_positions = str_c(pcr_position, collapse = ", "), 
    n_positions = n(), 
    .groups = "drop_last"
    ) |> 
  arrange(-n_positions) |> 
  summarize(
    n_distinct_pcr_positions = pcr_positions |> unique() |> length(), 
    n_LBP_plates = n(),
    pcr_positions = str_c(pcr_positions |> unique(), collapse = " | "), 
    n_positions = str_c(n_positions |> unique(), collapse = " | "), 
    .groups = "drop"
    ) 

tmp |>
  dplyr::count(n_LBP_plates, n_distinct_pcr_positions, n_positions, name = "n_samples") |>  # n_positions, 
  gt()

tmp |> filter(n_distinct_pcr_positions > 1) |> gt()

```

This looks fine, so we can propagate the `ext_lib_position` across plates.

```{r}

qpcr <- 
  qpcr |> 
  mutate(ext_lib_position_original = ext_lib_position) |>
  select(-any_of("ext_lib_position_new")) |>
  left_join(
   qpcr |> 
     filter(!is.na(ext_lib_position), target_type == "LBP strain") |>
     select(ext_lib_position_new = ext_lib_position, target_type, pcr_plate_id, well) |> 
     distinct(), 
   by = join_by(target_type, pcr_plate_id, well)
  )


qpcr |> 
  filter(ext_lib_position != ext_lib_position_new) |>
  nrow() == 0

qpcr |> 
  filter(is.na(ext_lib_position), !is.na(ext_lib_position_new)) |> 
  dplyr::count(ext_lib_position) |> 
  pull(ext_lib_position) |> 
  is.na()

qpcr <- 
  qpcr |> 
  mutate(
    ext_lib_position = 
      case_when(
        !is.na(ext_lib_position) ~ ext_lib_position,
        is.na(ext_lib_position) & !is.na(ext_lib_position_new) ~ ext_lib_position_new,
        TRUE ~ NA_character_
      )
  ) |> 
  select(-ext_lib_position_new)

```


Finally, we also noticed that some `vibr_sample_id` may not correspond to clinical samples but to potential positive controls:

```{r}

qpcr |> 
  filter(
    str_detect(vibr_sample_id, "[a-zA-Z]")
  ) |> 
  dplyr::count(target_type, vibr_sample_id, name = "n_wells") 

```






#### Harmonizing standards

We harmonized standard sample names because the 16S and LBP strain plates use different notations: 

```{r}

qpcr |> 
  dplyr::filter(str_detect(content, "Std")) |> 
  dplyr::count(target_type, content, sample, starting_quantity) |> 
  group_by(target_type) |>
  gt(row_group_as_column = TRUE)
  

```


We harmonized `content` to `"Std-[0-7]"`. 

```{r}

qpcr <-  
  qpcr |> 
  mutate(
    content_new = 
      case_when(
        (target != "16S") & str_detect(content, "Std") ~ content,
        (target == "16S") & str_detect(content, "Std") ~ str_c("Std-0", sample |> parse_number()),
        TRUE ~ content
      )# , 
    # sample =  
    #   case_when(
    #   str_detect(sample,  regex("^\\s*std\\s*10\\^\\s*[1-7]\\s*$", ignore_case = TRUE)) ~ "Standard", 
    #   TRUE ~ sample)
  )

qpcr |> 
  filter(str_detect(content, "Std")) |> 
  dplyr::count(target_type, content, content_new, starting_quantity) 

qpcr$content <- qpcr$content_new
qpcr <- qpcr |> select(-content_new)

```





#### Sample type

We now define the `qpcr_sample_type` variable, which is constructed from the information of the `content`, `sample`, and `vibr_sample_id` columns.


```{r}
#| eval: false
qpcr |> 
  dplyr::count(
    is.na(vibr_sample_id), 
    str_detect(content, "Std"), 
    str_detect(sample, "water"), 
    str_detect(content, "NTC"), 
    str_detect(vibr_sample_id, "EQ"), 
    str_detect(vibr_sample_id, "empty"), 
    is.na(replicate), 
    name = "n_wells"
  )

```



```{r}

qpcr <-  
  qpcr |> 
  mutate(
    qpcr_sample_type = 
      case_when(
        is.na(vibr_sample_id) & str_detect(content, "Std") ~ "Standard",
        is.na(vibr_sample_id) & str_detect(sample, "water") ~ "Negative control",
        is.na(vibr_sample_id) & str_detect(content, "NTC|Neg") ~ "Negative control",
        is.na(vibr_sample_id) & is.na(ext_lib_position) ~ "Water or empty",
        is.na(vibr_sample_id) & !is.na(ext_lib_position) ~ "Extraction control",
        !is.na(vibr_sample_id) & str_detect(vibr_sample_id, "LC115") ~ "Positive control",
        !is.na(vibr_sample_id) ~ "VIBRANT clinical sample",
        TRUE ~ "???"
      ),
    qpcr_control_type = 
      case_when(
        (qpcr_sample_type == "Standard") ~ "Standard",
        is.na(vibr_sample_id) & str_detect(sample, "water") ~ "Water",
        is.na(vibr_sample_id) & str_detect(content, "NTC") ~ "No template control",
        is.na(vibr_sample_id) & str_detect(content, "Neg") ~ "Negative control (unspecified)",
        !is.na(vibr_sample_id) & str_detect(vibr_sample_id, "LC115") ~ "LC115",
        (qpcr_sample_type == "VIBRANT clinical sample") ~ NA_character_,
        TRUE ~ qpcr_sample_type
      )
  )
    
```




```{r}
# qpcr |> dplyr::filter(target == "16S") |> arrange(qpcr_sample_type) |> View()
```


```{r}

qpcr |> dplyr::count(qpcr_sample_type, name = "n_wells") |> arrange(-n_wells) |> gt()
qpcr |> dplyr::count(qpcr_sample_type, qpcr_control_type, name = "n_wells") |> gt()

```




```{r}
#| fig-width: 20
#| fig-height: 6.5

qpcr_sample_type_colors <- c(
  "VIBRANT clinical sample" = "dodgerblue2",
  "Extraction control" = "dodgerblue4",
  "Standard" = "gold",
  "Negative control" = "lightblue1",
  "Positive control" = "orchid"
)


qpcr |> 
  select(pcr_plate_id, target_type, strain_group_qpcr, well_col, well_row, qpcr_sample_type) |>
  distinct() |> 
  ggplot() +
  aes(x = well_row |> factor(), y = well_col |> factor() |> fct_rev(), fill = qpcr_sample_type) +
  facet_grid(strain_group_qpcr |> str_replace_na("16S") ~ pcr_plate_id) +
  geom_tile() +
  scale_fill_manual(guide = guide_legend(nrow = 1), values = qpcr_sample_type_colors) +
  xlab("Well column") + ylab("Well row") +
  theme(
    legend.position = "bottom",
    legend.direction = "horizontal",
    axis.text = element_blank(),
    strip.text.x = element_text(angle = 90)
  )


```



```{r}
#| fig-width: 12
#| fig-height: 6.5

qpcr |> 
  filter(pcr_plate_id %in% c("Box 01 Daily", "Box 02 Daily", "MGH Home 1", "MGH Home 8 + Repeats")) |>
  select(pcr_plate_id, target_type, strain_group_qpcr, well_col, well_row, qpcr_sample_type) |>
  distinct() |> 
  ggplot() +
  aes(x = well_row |> factor(), y = well_col |> factor() |> fct_rev(), fill = qpcr_sample_type) +
  facet_grid(strain_group_qpcr |> str_replace_na("16S") ~ pcr_plate_id) +
  geom_tile() +
  scale_fill_manual(guide = guide_legend(nrow = 1), values = qpcr_sample_type_colors) +
  xlab("Well column") + ylab("Well row") +
  theme(
    legend.position = "bottom",
    legend.direction = "horizontal",
    axis.text = element_blank(),
    strip.text.x = element_text(angle = 90)
  )


```

### Unique qPCR plate and sample ID

We now create a unique qPCR plate ID `pcr_plate_uid` to uniquely identify a plate (for the LBP, the 5 plates have the same `pcr_plate_id`).

```{r}

qpcr <- 
  qpcr |> 
  mutate(
    pcr_plate_uid = 
      str_c(
        pcr_plate_id, " - ", 
        ifelse(
          target_type == "LBP strain", 
          str_c("LBP group ", strain_group_qpcr |> parse_number()),
          "16S"
        )
      )
  )

```

Then, we create a unique sample identifier (`qpcr_sample_id`) which is the `vibr_sample_id` for the clinical sample and which is constructed from the `pcr_plate_id`, `qpcr_sample_type` and the `sample` columns for the other samples.

```{r}


qpcr <- 
  qpcr |> 
  arrange(ext_lib_plate_nb) |> 
  mutate(
    pcr_plate_nb = pcr_plate_id |> factor() |> as.numeric() |> str_pad(width = 2, pad = 0),
    qpcr_sample_id = 
      case_when(
        (qpcr_sample_type %in% c("VIBRANT clinical sample", "Positive control")) ~ vibr_sample_id,
        (qpcr_sample_type == "Standard") ~ 
          str_c("std_", content |> str_remove("Std-"), "_plate_", pcr_plate_nb ),
        (qpcr_sample_type == "Negative control") ~ 
          str_c("NC_", sample, "_plate_", pcr_plate_nb),
        (qpcr_sample_type == "Extraction control") ~
          str_c("ext_ctrl_", ext_lib_position),
        TRUE ~ NA_character_
      )
  ) 


qpcr |> 
  dplyr::count(qpcr_sample_id, qpcr_sample_type, target) |> 
  arrange(-n) |> 
  group_by(qpcr_sample_id, qpcr_sample_type) |> 
  summarize(
    max_n_replicates_across_targets = max(n),
    min_n_replicates_across_targets = min(n),
    n_targets = n(),
    .groups = "drop"
  ) |> 
  dplyr::count(qpcr_sample_type, max_n_replicates_across_targets, min_n_replicates_across_targets, n_targets, name = "n_qpcr_sample_id") |>
  arrange(qpcr_sample_type, -n_qpcr_sample_id)
  
```

All `qpcr_sample_id` have 3 replicates except for 11 clinical samples that have 6 replicates.

Finally, we create a `qpcr_uid` which is the concatenation of the `qpcr_sample_id` and the replicate number to uniquely identify each well within a plate.

```{r}

qpcr <- 
  qpcr |> 
  arrange(pcr_plate_nb, well_col, well_row) |>
  group_by(qpcr_sample_id, target) |>
  mutate(replicate_nb = row_number()) |> 
  ungroup() |> 
  mutate(qpcr_uid = str_c(qpcr_sample_id, "_r", replicate_nb))

```

```{r}
#| eval: false

qpcr |> 
  dplyr::count(qpcr_uid, qpcr_sample_type, target) |> 
  arrange(-n) |> 
  group_by(qpcr_uid, qpcr_sample_type) |> 
  summarize(
    max_n_replicates_across_targets = max(n),
    min_n_replicates_across_targets = min(n),
    n_targets = n(),
    .groups = "drop"
  ) |> 
  dplyr::count(qpcr_sample_type, max_n_replicates_across_targets, min_n_replicates_across_targets, n_targets, name = "n_qpcr_sample_uid") |>
  arrange(qpcr_sample_type, -n_qpcr_sample_uid)

```





### Replicated VIBRANT sample IDs 

From building the `qpcr_sample_id`, we saw that 11 `vibr_sample_id` have 6 replicates instead of 3 replicates - this suggests duplication in the extraction plates or undergoing qPCR twice (if on different qPCR plates).


We check how many unique `ext_lib_position` and which plates are associated with these `vibr_sample_id`:

```{r}

tmp <- 
  qpcr |> 
  filter(!is.na(vibr_sample_id)) |> 
  group_by(vibr_sample_id, target) |> 
  mutate(n_replicates = n()) |> 
  ungroup() |> 
  filter(n_replicates > 3) |> 
  group_by(vibr_sample_id) |> 
  mutate(
    n_ext_lib_positions = ext_lib_position |> unique() |> length(),
    n_pcr_plates = pcr_plate_id |> unique() |> length(),
    plates = pcr_plate_id |> unique() |> str_c(collapse = ", ")
  ) |> 
  ungroup() |> 
  select(vibr_sample_id, n_replicates, n_ext_lib_positions, n_pcr_plates, plates) |> 
  distinct() 

tmp |> 
  gt()

```

Two of these samples may represent a mistake in the manifest because they have different positions, but are on the same plate. The other 9 samples are on different plates, so they likely represent samples that were extracted twice and run on two different qPCR plates.


:::callout-note
Check with Michael and/or Sinaye about these samples, and check in the 16S amplicon sequencing manifest if we also find these replicates 
:::


For now, we flag these samples as "Potential encoding mistake" and "Extracted twice" in a new variable `qpcr_sample_replication`:

```{r}

qpcr <- 
  qpcr |> 
  select(-any_of("qpcr_sample_replication")) |>
  left_join(
    tmp |> 
      mutate(
        qpcr_sample_replication = 
          case_when(
            n_ext_lib_positions > 1 & n_pcr_plates == 1 ~ "Potential encoding mistake",
            n_ext_lib_positions > 1 & n_pcr_plates > 1 ~ "Extracted twice",
            TRUE ~ "Once"
          )
      ) |> 
      select(vibr_sample_id, qpcr_sample_replication) |> 
      distinct(),
    by = join_by(vibr_sample_id)
  ) |> 
  mutate(
    qpcr_sample_replication = qpcr_sample_replication |> str_replace_na("Once")
  )

```




### Manifest data

The qPCR data did not contain any information about the participant ID (`pid`) or visit code (`visit_code`).

Consequently, we rely on the 16S rRNA amplicon sequencing manifest to retrieve this information.





```{r}

se_16S <- 
  readRDS(
    list.files(
      path = str_c(get_output_dir(), "01 Preprocessed and QCed/"),
      pattern = "04_se_16S_raw_.*\\.rds$", full.names = TRUE
    ) |>
      sort(decreasing = TRUE) |>
      magrittr::extract(1)
  ) 

```

```{r}

manifest <- 
  se_16S |> 
  colData() |>
  as.data.frame() |> 
  as_tibble() |> 
  select(
    sample_id_barcode, # should match the vibr_sample_id
    well_id, # should match the well information in the ext_lib_position
    ext_lib_plate_nb, # should match the ext_lib_plate_nb
    ext_lib_plate_type, 
    pid, visit_code, 
    sample_type, control_type, 
    randomized, location
    ) |> 
  distinct() |>
  mutate(
    uid = str_c(pid, visit_code, sep = "_"),
    visit_type = ifelse(str_sub(visit_code, 4,4) == 0, "Weekly", "Daily")
    )

```




```{r}

joined_clinical_samples <- 
  full_join(
    qpcr |> filter(!is.na(vibr_sample_id)) |> select(vibr_sample_id) |> distinct() |> mutate(in_qpcr = TRUE),
    manifest |> filter(!is.na(sample_id_barcode), sample_type == "Clinical sample") |> select(sample_id_barcode, visit_type) |> distinct() |> mutate(in_16S_manifest = TRUE),
    by = join_by(vibr_sample_id == sample_id_barcode)
  ) |> 
  mutate(
    in_qpcr = in_qpcr |> replace_na(FALSE),
    in_16S_manifest = in_16S_manifest |> replace_na(FALSE)
  ) 

joined_clinical_samples |> 
  dplyr::count(in_qpcr, in_16S_manifest, visit_type, name = "n_vibr_sample_id") |>
  gt()

```


Most samples have information in the 16S manifest, but some do not...

```{r}

joined_clinical_samples |> 
  filter(in_qpcr & !in_16S_manifest) |> 
  arrange(vibr_sample_id) |> 
  left_join(
    qpcr |>
      select(vibr_sample_id, ext_lib_plate_nb, ext_lib_position, pcr_plate_id) |> 
      distinct()
    ) |> 
  dplyr::count(
    in_qpcr, in_16S_manifest,
    pcr_plate_id
  ) |> 
  gt("Samples present in the qPCR data but not the 16S data.")

```

These may be samples that were not sent for 16S rRNA sequencing... so we'll need to request the information for these samples to Michael or Sinaye.

:::callout-important
Request missing metadata for these samples to Michael or Sinaye
:::


```{r}
#| eval: false

# Does not help much (only one sample) to directly use the phyloseq object
ps <- readRDS(str_c(get_data_dir(), "04 16S rRNA sequencing/raw_merged_all_pools_ps_20250523.rds")) 

ps_manifest <- 
  ps@sam_data |> 
  as.data.frame() |> 
  as_tibble() |> 
  select(
    Sample.ID.Barcode
    ) |> 
  distinct()

joined_clinical_samples_ps <- 
  full_join(
    qpcr |> filter(!is.na(vibr_sample_id)) |> select(vibr_sample_id) |> distinct() |> mutate(in_qpcr = TRUE),
    ps_manifest |> filter(!is.na(Sample.ID.Barcode)) |> select(Sample.ID.Barcode) |> distinct() |> mutate(in_16S_manifest = TRUE),
    by = join_by(vibr_sample_id == Sample.ID.Barcode)
  ) |> 
  mutate(
    in_qpcr = in_qpcr |> replace_na(FALSE),
    in_16S_manifest = in_16S_manifest |> replace_na(FALSE)
  ) 

joined_clinical_samples_ps |> 
  dplyr::count(in_qpcr, in_16S_manifest, name = "n_vibr_sample_id") |>
  gt()


```


#### Adding the manifest data for clinical samples

We first add the manifest data to the qPCR data based on the `vibr_sample_id` matching the `sample_id_barcode` in the manifest for those without missing `sample_id_barcode` in the manifest.

```{r}


manifest_columns <- 
  c("pid", "visit_code", "uid", "visit_type", "sample_type", "control_type", "randomized", "location")

manifest_barcoded_samples <- 
   manifest |> 
      filter(!is.na(sample_id_barcode)) |> 
      select(sample_id_barcode, all_of(manifest_columns)) |> 
      distinct()

```

However, we note that, for two barcodes, we have duplicates in the manifest, and they have different `visit_codes`:

```{r}

manifest_barcoded_samples |> 
  group_by(sample_id_barcode) |> mutate(n = n()) |> ungroup() |> 
  filter(n > 1) |> 
  arrange(sample_id_barcode) |> 
  left_join(
    manifest |> select(uid, well_id) |> distinct()
  ) |> 
  select(-control_type) 
 

```


They match our "suspicious" replicated samples from above! Yay!

So, we fix these two samples by concatenating their well ID to their barcode in both tables before merging:


```{r}

manifest <- 
  manifest |> 
  mutate(
    sample_id_barcode = 
      case_when(
        sample_id_barcode %in% c("2286665", "2292179") ~ str_c(sample_id_barcode, "_", well_id),
        TRUE ~ sample_id_barcode
      )
  )

qpcr <-
  qpcr |> 
  mutate(
    qpcr_sample_id = 
      case_when(
        vibr_sample_id %in% c("2286665", "2292179") ~ str_c(vibr_sample_id, "_", ext_lib_position |> str_remove(".*_")),
        TRUE ~ qpcr_sample_id
      ),
    vibr_sample_id = 
      case_when(
        vibr_sample_id %in% c("2286665", "2292179") ~ str_c(vibr_sample_id, "_", ext_lib_position |> str_remove(".*_")),
        TRUE ~ vibr_sample_id
      ),
    qpcr_sample_replication = 
      qpcr_sample_replication |> str_replace("Potential encoding mistake", "Once")
  ) |> 
  arrange(pcr_plate_nb, well_col, well_row) |>
  group_by(qpcr_sample_id, target) |>
  mutate(replicate_nb = row_number()) |> 
  ungroup() |> 
  mutate(qpcr_uid = str_c(qpcr_sample_id, "_r", replicate_nb))

```


And we merge to add the `pid`, `visit_code`, `uid`, etc.


```{r}

qpcr <- 
  qpcr |> 
  select(-any_of(manifest_columns)) |>
  left_join(
    manifest |> 
      filter(!is.na(sample_id_barcode)) |> 
      select(sample_id_barcode, all_of(manifest_columns)) |> 
      distinct(),
    by = join_by("vibr_sample_id" == "sample_id_barcode")
  )

```


:::callout-note
TODO later: also try to add the manifest data for the control samples
:::



```{r}
#| fig-width: 15
#| fig-height: 12

qpcr |> 
  filter(target == "16S") |> 
  select(
    well_col, well_row, pcr_plate_id, target_type, strain_group_qpcr,
    pid, visit_code, location
    ) |>
  distinct() |>
  ggplot() +
  aes(x = well_row |> factor(), y = well_col |> factor() |> fct_rev(), fill = pid) +
  # facet_grid(target_type + strain_group_qpcr ~ pcr_plate_id) +
  facet_wrap(pcr_plate_id ~ .) +
  geom_tile() +
  scale_fill_discrete(guide = guide_legend(nrow = 10)) +
  xlab("Well column") + ylab("Well row") +
  theme(
    legend.position = "bottom",
    legend.direction = "horizontal"
  )

```

```{r}
#| fig-width: 15
#| fig-height: 12

qpcr |> 
  filter(target == "16S") |> 
  select(
    well_col, well_row, pcr_plate_id, target_type, strain_group_qpcr,
    pid, visit_code, location, randomized
    ) |>
  distinct() |>
  ggplot() +
  aes(x = well_row |> factor(), y = well_col |> factor() |> fct_rev(), fill = randomized) +
  # facet_grid(target_type + strain_group_qpcr ~ pcr_plate_id) +
  facet_wrap(pcr_plate_id ~ .) +
  geom_tile() +
  scale_fill_discrete(guide = guide_legend(nrow = 10)) +
  xlab("Well column") + ylab("Well row") +
  theme(
    legend.position = "bottom",
    legend.direction = "horizontal"
  )

```


```{r}
#| fig-width: 15
#| fig-height: 10

qpcr |> 
  filter(target == "16S") |> 
  select(
    well_col, well_row, pcr_plate_id, target_type, strain_group_qpcr,
    pid, visit_code, location
    ) |>
  distinct() |> 
  ggplot() +
  aes(x = well_row |> factor(), y = well_col |> factor() |> fct_rev(), fill = location) +
  # facet_grid(target_type + strain_group_qpcr ~ pcr_plate_id) +
  facet_wrap(pcr_plate_id ~ .) +
  geom_tile() +
  scale_fill_discrete(guide = guide_legend(nrow = 4)) +
  xlab("Well column") + ylab("Well row") +
  theme(
    legend.position = "bottom",
    legend.direction = "horizontal"
  )

```


```{r}
#| fig-width: 15
#| fig-height: 10

qpcr |> 
  filter(target == "16S") |> 
  select(
    well_col, well_row, pcr_plate_id, target_type, strain_group_qpcr,
    pid, visit_code
    ) |>
  distinct() |> 
  ggplot() +
  aes(x = well_row |> factor(), y = well_col |> factor() |> fct_rev(), fill = visit_code) +
  # facet_grid(target_type + strain_group_qpcr ~ pcr_plate_id) +
  facet_wrap(pcr_plate_id ~ .) +
  geom_tile() +
  scale_fill_discrete(guide = guide_legend(nrow = 4)) +
  xlab("Well column") + ylab("Well row") +
  theme(
    legend.position = "bottom",
    legend.direction = "horizontal"
  )

```

#### Adding the manifest data for control samples

> TODO

#### `sample_type` and `control_type`

> TODO


### Relationships between columns

#### Observations and calibration curves

Observed values are the `cq` values.

`starting_quantity` are computed from the `cq` values using the calibration curves fitted on the standard values.

$$C = f(SQ^*)$$


where $C$ is the observed `cq` value for the standard, $SQ^*$ is the known starting quantity `starting_quantity` for the standards, and $f$ is the calibration function.


:::callout-note
I assume that, either the standards are **not** diluted, and that the `quant_adjusted` and `copies_per_swabs` are not correct for the standards, or that the standards are diluted and that the calibration curves are fitted on the `quant_adjusted`:
:::

```{r}
qpcr |>
  dplyr::filter(qpcr_sample_type == "Standard", target != "16S") |> 
  select(
    sample, starting_quantity, dilution_factor, quant_adjusted, copies_per_swab
  ) |> 
  distinct() |> 
  arrange(sample, dilution_factor) |> 
  gt()
```


```{r}
#| eval: false
#| fig-height: 3.5
#| fig-width: 10

qpcr |>
  dplyr::filter(qpcr_sample_type == "Standard") |> 
  arrange(-dilution_factor) |>
  ggplot() +
  aes(
    # x = starting_quantity |> log10(), 
    x = quant_adjusted |> log10(),
    y = cq, 
    col = dilution_factor |> factor()
  ) +
  geom_point(size = 1, alpha = 0.2) +
  scale_color_manual(
    "Dilution factor", 
    values = colorRampPalette(c("black", "dodgerblue1"))(4)
    ) +
  facet_wrap(. ~ strain_group_qpcr + target, ncol = 9) 

```


For all clinical samples, the `starting_quantity` is computed from the `cq` values using the calibration curve fitted on the standard values.

$$\hat{SQ} = f^{-1}(C)$$

where $\hat{SQ}$ is the estimated starting quantity `starting_quantity` for the clinical samples, $C$ is the observed `cq` value for the clinical sample, and $f^{-1}$ is the inverse of the calibration function.


If $C$ is not observed (*i.e.*, assumed to be larger than the total number of cycles), then $\hat{SQ}$ is estimated as 0.

```{r}
#| fig-height: 6
#| fig-width: 10

# qpcr |> 
#   ggplot() +
#   aes(x = starting_quantity |> log10(), y = cq, col = qpcr_sample_type) +
#   geom_point(size = 0.5, alpha = 0.4) +
#   facet_grid(strain_group_qpcr + target ~ ext_lib_plate_nb) 


qpcr |> 
  ggplot() +
  aes(
    x = starting_quantity |> log10(), 
    y = cq, 
    col = ext_lib_plate_nb |> factor(),
    size = (qpcr_sample_type == "Standard")
    ) +
  geom_point(alpha = 0.5) +
  facet_wrap(strain_group_qpcr + target ~ ., ncol = 6) +
  scale_size_manual("Standard", values = c(0.2, 1)) +
  scale_color_viridis_d("Extraction plate number", direction = -1, option = "A", end = 0.8) 

```

It looks like $f$ is a linear function of $\log(SQ^*)$: $C = \beta_0 + \beta_1 \log(SQ^*)$.  This seems appropriate for this data.


#### Adjusted quantities

Adjusted quantities (`quant_adjusted`) are then computed from the estimated `starting_quantity` values using the dilution factors.

$\hat{Q} = \hat{SQ} \times d$

where $\hat{Q}$ is the estimated adjusted quantity (`quant_adjusted`), $\hat{SQ}$ is the estimated starting quantity (`starting_quantity`) for the clinical samples, and $d$ is the dilution factor.

```{r}
#| fig-height: 5
#| fig-width: 15

qpcr |>
  ggplot() +
  aes(
    x = starting_quantity |> log10(), 
    y = quant_adjusted |> log10(), 
    col = dilution_factor |> factor()
    ) +
  geom_point() +
  facet_wrap(. ~ strain_group_qpcr + target, ncol = 9) +
  scale_color_manual(
    "Dilution factor", 
    values = colorRampPalette(c("dodgerblue1", "gray90"))(6)
    )

```

`quant_adjusted` = `starting_quantity` x `dilution_factor`:

```{r}
#| fig-height: 5
#| fig-width: 15

qpcr |>
  ggplot() +
  aes(
    x = (starting_quantity * dilution_factor) |> log10(), 
    y = (quant_adjusted) |> log10(), 
    col = dilution_factor |> factor()
    ) +
  geom_point() +
  facet_wrap(. ~ strain_group_qpcr + target, ncol = 9) +
  scale_color_manual(
    "Dilution factor", 
    values = colorRampPalette(c("dodgerblue1", "gray90"))(6)
    )

```

#### Copies per swab

`copies_per_swab` are the `adjusted_quant` multiplied by a constant factor estimated to be the number of bacteria in 1 concentration unit.

Here, that number is 250 for all targets.


```{r}
#| fig-height: 5
#| fig-width: 15

# strain_group_qpcr + target

qpcr |>
  # dplyr::filter(target != "16S") |> 
  ggplot() +
  aes(
    x = (quant_adjusted * 250) |> log10(), 
    y = copies_per_swab |> log10(), 
    col =  target
    ) +
  geom_abline(intercept = 0, slope = 1, col = "gray") +
  geom_point(size = 0.5, alpha = 0.4) +
  facet_wrap(. ~ ext_lib_plate_nb , ncol = 6) 
```



```{r}
#| eval: false
qpcr |>
  dplyr::filter(target == "16S") |> 
  mutate(
    r = copies_per_swab / (quant_adjusted )
  ) |> 
  pull(r) |> 
  hist()


```


### Dilution factors

For these samples, the dilution factor was the sam (= 10) across all plates:

```{r}
qpcr$dilution_factor |> unique()
```


## Exploratory & QC analyses


### CQ and Copies per swabs per well


```{r}
#| fig-height: 15
#| fig-width: 30

qpcr |> 
  select(
    starts_with("well"), 
    pcr_plate_nb, 
    target,
    strain_group_qpcr, 
    ext_lib_plate_nb, 
    cq
    ) |> 
  distinct() |> 
  ggplot() +
  aes(
    x = well_row |> factor(), 
    y = well_col |> fct_rev(), 
    fill = cq
    ) +
  geom_tile() +
  facet_grid(strain_group_qpcr + target ~ ext_lib_plate_nb, scales = "free", space = "free") +
  xlab("Well column") + ylab("Well row") +
  theme(
    axis.text = element_blank()
  )

```

```{r}
#| fig-height: 15
#| fig-width: 30

qpcr |> 
  select(
    starts_with("well"), 
    pcr_plate_id, 
    target,
    strain_group_qpcr, 
    ext_lib_plate_nb, 
    copies_per_swab
    ) |> 
  distinct() |> 
  ggplot() +
  aes(
    x = well_row |> factor(), 
    y = well_col |> fct_rev(), 
    fill = copies_per_swab |> asinh()
    ) +
  geom_tile() +
  facet_grid(strain_group_qpcr + target ~ ext_lib_plate_nb, scales = "free", space = "free") +
  xlab("Well column") + ylab("Well row") 

```






### Total number of copies per swab per sample type


```{r}
#| fig-width: 13
#| fig-height: 5

g <- 
  qpcr |> 
  ggplot() +
  aes(x = target, y = copies_per_swab, col = qpcr_sample_type, fill = qpcr_sample_type) +
  geom_boxplot(alpha = 0.5) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  facet_grid(. ~ LBP, scales = "free", space = "free")

g 

g + scale_y_log10()

```



```{r}
#| fig-width: 13
#| fig-height: 5


g <- 
  qpcr |> 
  ggplot() +
  aes(x = pcr_plate_nb |> factor(), y = copies_per_swab, col = target, fill = target) +
  geom_boxplot(alpha = 0.5) +
  facet_grid(qpcr_sample_type ~ ., scales = "free") +
  xlab("Plate number") +
  theme(
    strip.text.y = element_text(angle = 0),
    strip.text.x = element_text(angle = 90, hjust = 0)
  )

g 

g + scale_y_log10() 

```

There is one plate that may have suffered contamination:

```{r}
#| fig-width: 12
#| fig-height: 8

qpcr |> 
  filter(pcr_plate_nb == "04", target != "16S") |> 
  select(
    starts_with("well"), 
    pcr_plate_nb, 
    target,
    strain_group_qpcr, 
    ext_lib_plate_nb, 
    cq
    ) |> 
  distinct() |> 
  ggplot() +
  aes(
    x = well_row |> factor(), 
    y = well_col |> fct_rev(), 
    fill = cq
    ) +
  geom_tile() +
  facet_wrap(. ~ strain_group_qpcr + target,  ncol = 6) + # scales = "free", space = "free",
  xlab("Well column") + ylab("Well row") +
  theme(
    axis.text = element_blank()
  )

```

It looks like 1 well in the LBP group 5 (`VMRC_5`) got an expected Cq reading for one of the 3 water samples (bottom right).
This does not look like an actual contamination problem, and this appears to be the only issue with the Negative Controls:

```{r}
#| fig-width: 12
#| fig-height: 6

qpcr |> 
    dplyr::filter(qpcr_sample_type %in% c("Negative control")) |> 
    group_by(sample, pcr_plate_id, pcr_plate_nb, ext_lib_plate_nb, target) |>
    mutate(replicate_nb = row_number()) |> 
    ungroup() |> 
    ggplot() +
    aes(x = pcr_plate_nb, y = copies_per_swab, label = replicate_nb, col = (copies_per_swab == 0)) +
    geom_text(size = 3) +
    facet_grid(strain_group_qpcr + target ~ ., scales = "free_x", space = "free_x") +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      strip.text.y = element_text(angle = 0)
    ) 

```


### Standards

```{r}
#| eval: false
#| fig-width: 12

qpcr |> 
  dplyr::filter(qpcr_sample_type %in% "Standard") |>
  ggplot() +
  aes(x = starting_quantity, y = cq, col = replicate_nb |> factor()) +
  geom_point(alpha = 0.5, size = 0.5) +
  facet_grid(strain_group_qpcr + target ~ ext_lib_plate_nb) +
  scale_x_log10() +
  theme(
    strip.text.y = element_text(angle = 0),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
  
```



::: panel-tabset
```{r}
#| results: asis
#| fig-width: 12
#| fig-height: 6


targets <- 
  qpcr |> 
  select(strain_group_qpcr, target) |> 
  distinct() |> 
  arrange(strain_group_qpcr, target) |>
  pull(target)

purrr::walk(
  targets,
  \(x) {
    cat('### Target ', x, '\n\n')

    g <- 
      qpcr |> 
      dplyr::filter(qpcr_sample_type %in% "Standard", target == x) |>
      mutate(std_nb = content |> str_remove("Std-") |> parse_number()) |> 
      ggplot() +
      aes(x = starting_quantity, y = cq, col = replicate_nb |> factor()) +
      geom_text(alpha = 0.5, aes(label = std_nb)) +
      facet_wrap(target + strain_group_qpcr + pcr_plate_nb ~ ., nrow = 3) +
      scale_x_log10() +
      theme(
        strip.text.y = element_text(angle = 0),
        axis.text.x = element_text(angle = 45, hjust = 1)
      )  
      g |> print()
    
    cat('\n\n')
  }
)
```
:::



```{r}
#| fig-width: 12
#| fig-height: 6


qpcr |> 
  dplyr::filter(qpcr_sample_type %in% "Standard") |>
  mutate(std_nb = content |> str_remove("Std-") |> parse_number()) |> 
  ggplot() +
  aes(x = starting_quantity, y = cq, col = pcr_plate_nb) +
  geom_path(aes(group = interaction(ext_lib_plate_nb, replicate_nb)), alpha = 0.2) +
  geom_text(alpha = 0.2, aes(label = pcr_plate_nb), size = 3) +
  facet_wrap(strain_group_qpcr + target ~ ., ncol = 9) +
  scale_x_log10() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

```

Calibration curves look mostly good - maybe we could check the data for the plate #28 and strain group 1 (VMRC_1)....

```{r}
#| fig-width: 12
#| fig-height: 6


qpcr |> 
  dplyr::filter(
    strain_group_qpcr == "VMRC_1"
    ) |> 
  ggplot() +
  aes(x = pcr_plate_nb, y = cq, fill = pcr_plate_nb == 28) +
  facet_grid(strain_group_qpcr + target ~ ., scales = "free") +
  geom_violin() +
  geom_point(aes(size = (qpcr_sample_type == "Standard")), alpha = 0.25) +
  scale_size_manual("Standard", values = c(0.1, 1.5)) +
  guides(fill = "none") +
  theme(legend.position = "bottom")



qpcr |> 
  dplyr::filter(
    strain_group_qpcr == "VMRC_1"
    ) |> 
  ggplot() +
  aes(x = pcr_plate_nb, y = copies_per_swab |> asinh(), fill = pcr_plate_nb == 28) +
  facet_grid(strain_group_qpcr + target ~ ., scales = "free") +
  geom_violin() +
  geom_point(aes(size = (qpcr_sample_type == "Standard")), alpha = 0.25) +
  scale_size_manual("Standard", values = c(0.1, 1.5)) +
  guides(fill = "none") +
  theme(legend.position = "bottom")

```


It looks like something went *different* for this plate, but it looks like the standards fulfilled their role and that it did not substantially affected the copies per swabs.



### Extraction controls

```{r}
#| fig-width: 12
#| fig-height: 8

qpcr |> 
  dplyr::filter(qpcr_sample_type %in% c("Extraction control")) |> 
  ggplot() +
  aes(x = qpcr_sample_id, y = copies_per_swab, col = replicate_nb |> factor()) +
  facet_grid(strain_group_qpcr + target ~ pcr_plate_id, scales = "free_x", space = "free_x") +
  scale_y_log10() +
  geom_point(size = 0.5, alpha = 0.5) +
  theme(
    axis.text.x = element_blank(), # element_text(angle = 45, hjust = 1),
    strip.text.y = element_text(angle = 0),
    strip.text.x = element_text(angle = 90, hjust = 0),
    legend.position = "bottom"
  )

```

:::callout-note
TODO - identify what are these using the well positions and the 16S manifest.
:::


### Positive controls


```{r}
#| fig-width: 12
#| fig-height: 8

qpcr |> 
  dplyr::filter(qpcr_sample_type %in% c("Positive control")) |> 
  ggplot() +
  aes(x = qpcr_sample_id, y = copies_per_swab, col = replicate_nb |> factor()) +
  # ggh4x::facet_nested(pcr_plate_id ~ strain_group_qpcr + target, scales = "free_x", space = "free_x") +
  facet_wrap(strain_group_qpcr + target ~ .,  ncol = 6) +
  geom_point(size = 1, alpha = 0.5) +
  geom_line(aes(group = replicate_nb), alpha = 0.5) +
  scale_y_log10() +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
    strip.text.y = element_text(angle = 90),
    strip.text.x = element_text(angle = 0, hjust = 0.5) # element_text(angle = 90, hjust = 0.5)
  )

```


```{r}
#| fig-width: 9
#| fig-height: 7

qpcr |> 
  dplyr::filter(qpcr_sample_type %in% c("Positive control")) |> 
  ggplot() +
  aes(x = qpcr_sample_id, y = copies_per_swab, col = target) +
  geom_point(size = 1, alpha = 0.5) +
  geom_line(aes(group = interaction(target, replicate_nb)), alpha = 0.5) +
  ggrepel::geom_text_repel(
    data  = 
      qpcr |> 
      dplyr::filter(
        qpcr_sample_type %in% c("Positive control"), 
        replicate_nb == 3,
        qpcr_sample_id |> str_detect("-3|8")
        ),
    aes(label = target), force = 1, max.overlaps = 5, hjust = 0, 
    show.legend = FALSE
  ) +
  scale_y_log10() +
  xlab("") +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 45, hjust = 1), # , vjust = 0.5
    strip.text.y = element_text(angle = 90),
    strip.text.x = element_text(angle = 0, hjust = 0.5) # element_text(angle = 90, hjust = 0.5)
  ) +


qpcr |> 
  dplyr::filter(qpcr_sample_type %in% c("Positive control")) |> 
  ggplot() +
  aes(x = qpcr_sample_id, y = copies_per_swab, col = strain_group_qpcr) +
  geom_point(size = 1, alpha = 0.5) +
  geom_line(aes(group = interaction(target, replicate_nb)), alpha = 0.5) +
  scale_y_log10() +
  xlab("") +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 45, hjust = 1), # , vjust = 0.5
    strip.text.y = element_text(angle = 90),
    strip.text.x = element_text(angle = 0, hjust = 0.5) # element_text(angle = 90, hjust = 0.5)
  )

```




### Clinical samples

```{r}
#| fig-width: 20
#| fig-height: 10


map(
  .x = list(c(1:14), c(15:27), c(28:35)),
  ~ qpcr |> 
    dplyr::filter(
      qpcr_sample_type %in% c("VIBRANT clinical sample"),
      pcr_plate_nb %in% .x
    ) |> 
    group_by(vibr_sample_id, sample, pcr_plate_id, ext_lib_plate_nb, target) |>
    mutate(
      replicate_nb = row_number(),
      median_cps = median(copies_per_swab, na.rm = TRUE),
      mean_cps = mean(copies_per_swab, na.rm = TRUE)
    ) |> 
    ungroup() |> 
    mutate(vibr_sample_id = vibr_sample_id |> fct_reorder(mean_cps)) |>
    ggplot() +
    aes(x = vibr_sample_id, y = copies_per_swab, label = replicate_nb, col = replicate_nb |> factor()) +
    geom_line(aes(group = vibr_sample_id), col = "black", linewidth = 0.1) +
    geom_text(size = 3) +
    scale_y_log10() +
    scale_color_discrete("replicate") +
    scale_x_discrete("Samples", breaks = NULL) +
    facet_grid(strain_group_qpcr + target ~ ext_lib_plate_nb, scales = "free_x", space = "free_x") +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      strip.text.y = element_text(angle = 0)
    )
)


```



#### Samples with replicates across plates



```{r}
#| fig-width: 14
#| fig-height: 8

qpcr |> 
  dplyr::filter(qpcr_sample_type %in% c("VIBRANT clinical sample")) |> 
  group_by(qpcr_sample_id, vibr_sample_id, target) |>
  mutate(
    n_replicates = n(),
    replicate_nb = row_number(),
    median_cps = median(copies_per_swab, na.rm = TRUE),
    mean_cps = mean(copies_per_swab, na.rm = TRUE),
    min_ext_lib_plate_nb = min(ext_lib_plate_nb, na.rm = TRUE),
    min_pcr_plate_id = min(pcr_plate_id, na.rm = TRUE)
    ) |> 
  ungroup() |> 
  dplyr::filter(n_replicates > 3) |>
  mutate(vibr_sample_id = vibr_sample_id |> fct_reorder(mean_cps)) |>
  ggplot() +
  aes(x = copies_per_swab, y = vibr_sample_id) +
  facet_wrap(. ~ strain_group_qpcr + target, scales = "free_x", ncol = 6) +
  geom_line(alpha = 0.2) +
  geom_text(aes(label = replicate_nb, col = (ext_lib_plate_nb == 35)), size = 3) +
  scale_x_log10() +
  scale_color_discrete("2nd extraction") +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
    strip.text.y = element_text(angle = 0),
    strip.text.x = element_text(angle = 0, hjust = 0.5)
  )

```


For most samples with replicates across plates, the values are higher in the 1st extraction (or 1st qPCR run). To decide which one to trust, it would be important to understand the reasons that motivated duplicates.

:::callout-important
@Michael/Sinaye: do you know why these samples were extracted/ran twice?
:::

In the meanwhile, we will take the median across all replicates...


## Aggregation across replicates

```{r}

qpcr <- 
  qpcr |> 
  group_by(qpcr_sample_id, target) |> 
  mutate(
    copies_per_swab_median = median(copies_per_swab, na.rm = TRUE),
    copies_per_swab_range = max(copies_per_swab, na.rm = TRUE) - min(copies_per_swab, na.rm = TRUE),
  ) |> 
  ungroup()

```




```{r}
#| fig-width: 21
#| fig-height: 5.5

qpcr |> 
  dplyr::filter(qpcr_sample_type %in% c("VIBRANT clinical sample")) |>
  group_by(qpcr_sample_id) |> mutate(n_target_detected = sum(copies_per_swab_median > 0)) |> ungroup() |>
  mutate(qpcr_sample_id = qpcr_sample_id |> fct_reorder(n_target_detected)) |>
  ggplot() +
  aes(x = qpcr_sample_id, y = target, fill = copies_per_swab_median |> log10()) +
  geom_tile() +
  facet_grid(strain_group_qpcr + LBP  ~ ext_lib_plate_nb, scales = "free", space = "free") +
  scale_fill_gradient(low = "dodgerblue1", high = "black", na.value = "white") +
  theme(
    axis.text.x = element_blank(),
    legend.position = "bottom"
  ) +
  ggtitle("Median of `copies_per_swabs`")
  

```


### Longitudinal profiles

When looking at the longitudinal patterns for randomized participants, we do not notice an over-representation of a specific plate or group in the "isolated" positives:

```{r}
#| fig-width: 15
#| fig-height: 20

qpcr |> 
  dplyr::filter(
    sample_type %in% c("Clinical sample"), 
    visit_code %in% c(1000:1007, 1101:1107, 1200:1207, 1300:1307, 1400:1407, 1500:1507)
  ) |>
  group_by(pid) |> mutate(n_target_detected = sum(copies_per_swab_median[!is.na(LBP)] > 0)) |> ungroup() |>
  mutate(pid = pid |> fct_reorder(n_target_detected)) |>
  ggplot() +
  aes(
    x = pid, y = visit_code |> fct_rev(), 
    fill = ext_lib_plate_nb |> factor(), 
    alpha = copies_per_swab_median |> asinh()
  ) +
  geom_tile() +
  facet_grid(strain_group_qpcr + target ~ ., scales = "free") +
  scale_fill_discrete("Extraction plate number") +
  scale_alpha_continuous(limits = c(0, 10)) +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
    strip.text.y = element_text(angle = 0),
    legend.position = "right",
    legend.direction = "vertical"
  )
  
```

```{r}
#| fig-width: 15
#| fig-height: 10

qpcr |> 
  dplyr::filter(
    sample_type %in% c("Clinical sample"),
    target == "C0022A1",
    visit_code %in% c(1000:1007, 1101:1107, 1200:1207, 1300:1307, 1400:1407, 1500:1507)
  ) |>
  ggplot() +
  aes(
    x = pid, y = visit_code |> fct_rev(), 
    fill = pcr_plate_nb, # %in% c("03", "07")
    alpha = copies_per_swab_median |> asinh()
  ) +
  geom_tile() +
  geom_text(aes(label = pcr_plate_nb), size = 2.5) +
  facet_grid(target ~ ., scales = "free") +
  scale_alpha_continuous(limits = c(0, 10)) +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
    strip.text.y = element_text(angle = 0),
    legend.position = "bottom",
    legend.direction = "horizontal"
  )
  
```

However, we note strong confounding between participants and plates - it would have been much better to randomize the samples/participants a bit more... Hard to tell if there is a plate effect or not.

:::callout-note
We could check if detection "transitions" (going from not-detected to detected and/or vice-versa) are less likely to happen within the same plate than between plates.
:::



```{r}
#| eval: false
#| fig-width: 15
#| fig-height: 7

qpcr |> 
  dplyr::filter(
    sample_type %in% c("Clinical sample"), 
    target == "C0022A1",
    # sample_category %in% c("Expected sample"),
    visit_code %in% c(1000:1007, 1101:1107, 1201:1207, 1301:1307, 1401:1407)
  ) |>
  group_by(pid) |> mutate(n_target_detected = sum(copies_per_swab_median[!is.na(LBP)] > 0)) |> ungroup() |>
  mutate(pid = pid |> fct_reorder(n_target_detected)) |>
  ggplot() +
  aes(x = pcr_plate_nb, y = copies_per_swab_median |> asinh(), col = pcr_plate_nb, fill = pcr_plate_nb) +
  facet_wrap(. ~ visit_code, nrow = 7, dir = "v") + 
  # ggbeeswarm::geom_quasirandom(size = 0.5, alpha = 0.5) +
  stat_summary(fun = median, geom = "point", col = "black") +
  # geom_violin(col = "transparent") 
  geom_boxplot(outlier.shape = NA, varwidth = TRUE, linewidth = 0.3) 
  
```




The number of positives at pre-product visits seems a bit high...


```{r}
#| fig-width: 20
#| fig-height: 12

qpcr |> 
  dplyr::filter(
    target != "16S",
    sample_type %in% c("Clinical sample"), 
    visit_code %in% c(1000:1007, 1101:1107, 1200:1207, 1300:1307, 1400:1407) # , 1500:1507
  ) |>
  # group_by(mg_pid) |> mutate(n_target_detected = sum(copies_per_swab_adj_median[!is.na(LBP)] > 0)) |> ungroup() |>
  # mutate(mg_pid = mg_pid |> fct_reorder(n_target_detected)) |>
  mutate(pid = pid |> factor()) |>
  mutate(target = target |> fct_reorder(as.numeric(factor(LBP)) + as.numeric(factor(strain_origin))/10)) |> 
  ggplot() +
  aes(
    x = target, y = pid |> fct_rev(), 
    fill = LBP,
    alpha = copies_per_swab_median |> log10()
  ) +
  geom_tile() +
  facet_grid(. ~ visit_code) +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
    strip.text.x = element_text(angle = 90),
    # strip.text.y = element_text(angle = 0),
    legend.position = "bottom"
  )
  
```
There are clear patterns in the data, hinting at the participants' arms :)

However, this also still suggests that there might be quite a lot of false positive and a low specificity for the qPCR probes.

```{r}
#| fig-width: 12
#| fig-height: 4

qpcr |> 
  dplyr::filter(
    sample_type %in% c("Clinical sample"), 
    # sample_category %in% c("Expected sample"),
    visit_code %in% c(1000:1007, 1101:1107, 1200:1207, 1300:1307, 1400:1407, 1500:1507),
    target == "16S"
    ) |>  
  arrange(pid, visit_code) |> 
  select(pid, visit_code, copies_per_swab_median) |>
  distinct() |> 
  ggplot() +
  aes(x = visit_code, y = copies_per_swab_median, col = pid) +
  geom_boxplot(alpha = 0.4, fill = "dodgerblue1", color = "dodgerblue1", outlier.shape = NA) +
  geom_line(aes(group = pid), alpha = 0.2) +
  ggbeeswarm::geom_quasirandom(width = 0.2, size = 0.5) +
  scale_y_log10() +
  guides(col = "none") +
  ggtitle("16S copies per swab") +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)
  )
  
```



## Creating `SummarizedExperiment` objects

We create two `Summarized Experiment` objects:

- one with all values as provided in the original file, where each "sample" is a plate well and each feature is a target (LBP taxa)

- one with summarized values (aggregated across replicates) where each "sample" is a VIBRANT sample ID (not including "biological" control samples at the moment) and each feature is a target (LBP taxa)


### Raw `SummarizedExperiment` object

We create a `SummarizedExperiment` object with the following assays:

  + `dilution_factor`
  + `cq` 
  + `starting_quantity`
  + `cq_mean`
  + `quant_adjusted`
  + `copies_per_swab`
  
  
The "samples" are defined by the `qpcr_uid` column (one per well and plate) and the "features" are defined by the `target` column (*i.e.*, the LBP taxa).
  
The `colData` contains the following columns: 
  
  + `qpcr_uid` (the qPCR specific unique identifier)
  + `uid` (the VIBRANT cross-assay unique sample identifier)
  + `qpcr_sample_id`
  + `vibr_sample_id`
  + `qpcr_sample_type`
  + `sample_type`
  + `control_type`
  + `pcr_plate_id`
  + `ext_lib_plate_nb` 
  + `ext_lib_plate_id`

  
The `rowData` contains the following columns:
  
  + `fluor`
  + `strain_group_qpcr`
  + `taxon_label`
  + `LBP`
  + `strain_id`
  + `strain_origin`
  + `biose_id`
  
  
```{r}
#| eval: false

qpcr |> dplyr::count(qpcr_uid) |> dplyr::count(n)

qpcr |> dplyr::count(qpcr_uid) |> nrow()


qpcr |> dplyr::count(qpcr_uid) |> dplyr::filter(n != 16) |> View()

qpcr |> 
  select(
    qpcr_uid, 
    uid, pid, visit_code,
    qpcr_sample_type,  sample_type, control_type, 
    qpcr_sample_id, vibr_sample_id, replicate_nb, 
    ext_lib_plate_nb, ext_lib_plate_id
  ) |> 
  distinct() |> 
  group_by(qpcr_uid) |> mutate(n = n()) |> ungroup() |> 
  dplyr::filter(n > 1) |> 
  arrange(qpcr_uid)

qpcr |> 
  dplyr::filter(qpcr_sample_id == "1588") |> 
  select(qpcr_sample_id, qpcr_uid, pcr_plate_id, well_row, well_col, ext_lib_plate_nb, ext_lib_plate_id, target) |> 
  arrange(target, pcr_plate_id,  qpcr_uid, well_row, well_col) |> 
  View()

```
  

```{r}

make_raw_qpcr_SE <- function(qpcr){
  
  qpcr <- 
    qpcr |> 
    arrange(ext_lib_plate_nb, well_col, well_row) |>
    mutate(qpcr_uid = qpcr_uid |> fct_inorder()) |> 
    arrange(strain_group_qpcr, fluor) |> 
    mutate(target = target |> fct_inorder()) |> 
    arrange(qpcr_uid, target)
    
  # ASSAYS
  
  dilution_assay <- 
    qpcr |>
    select(qpcr_uid, target, dilution_factor) |> 
    arrange() |> 
    pivot_wider(names_from = qpcr_uid, values_from = dilution_factor) |> 
    as.data.frame() |> 
    column_to_rownames("target") 
  
  cq_assay <- 
    qpcr |>
    select(qpcr_uid, target, cq) |> 
    arrange() |> 
    pivot_wider(names_from = qpcr_uid, values_from = cq) |> 
    as.data.frame() |> 
    column_to_rownames("target") 
  
  starting_quantity_assay <- 
    qpcr |>
    select(qpcr_uid, target, starting_quantity) |> 
    arrange() |> 
    pivot_wider(names_from = qpcr_uid, values_from = starting_quantity) |> 
    as.data.frame() |> 
    column_to_rownames("target")
  
   cq_mean_assay <- 
    qpcr |>
    select(qpcr_uid, target, cq_mean) |> 
    arrange() |> 
    pivot_wider(names_from = qpcr_uid, values_from = cq_mean) |> 
    as.data.frame() |> 
    column_to_rownames("target")
   
   quant_adjusted_assay <- 
     qpcr |>
     select(qpcr_uid, target, quant_adjusted) |> 
     arrange() |> 
     pivot_wider(names_from = qpcr_uid, values_from = quant_adjusted) |> 
     as.data.frame() |> 
     column_to_rownames("target")
   
   copies_per_swab_assay <- 
     qpcr |>
     select(qpcr_uid, target, copies_per_swab) |> 
     arrange() |> 
     pivot_wider(names_from = qpcr_uid, values_from = copies_per_swab) |> 
     as.data.frame() |> 
     column_to_rownames("target")
  
  
    # COLDATA
   coldata <- 
     qpcr |> 
     select(
       qpcr_uid, 
       uid, pid, visit_code,
       qpcr_sample_type,  sample_type, control_type, 
       qpcr_sample_id, vibr_sample_id, replicate_nb, 
       pcr_plate_id, pcr_plate_nb, ext_lib_plate_nb #, ext_lib_plate_id
       ) |> 
     distinct() |> 
     arrange(qpcr_uid) |> 
     as.data.frame() |> 
     mutate(rownames = qpcr_uid) |> 
     column_to_rownames("rownames") 

    # ROWDATA
   rowdata <-
     qpcr |> 
     select(
       target, fluor, strain_group_qpcr, 
       taxon_label, LBP, strain_id, strain_origin, biose_id
       ) |> 
     distinct() |> 
     group_by(
       target, fluor, strain_group_qpcr, 
       taxon_label, LBP, strain_id, strain_origin, biose_id
       ) |> 
     arrange(target) |> 
     as.data.frame() |> 
     mutate(rownames = target) |> 
     column_to_rownames("rownames")
  
   
   SE <- SummarizedExperiment(
     assays = list(
       dilution = dilution_assay |> as.matrix(),
       cq = cq_assay |> as.matrix(),
       cq_mean = cq_mean_assay |> as.matrix(),
       starting_quantity = starting_quantity_assay |> as.matrix(),
       quant_adjusted = quant_adjusted_assay |> as.matrix(),
       copies_per_swab = copies_per_swab_assay |> as.matrix()
     ),
     colData = coldata,
     rowData = rowdata,
     metadata = list(
       description = "Raw qPCR data from the VIBRANT study",
       date = today(),
       assay_and_coldata_dictionary = dictionary
     )
   )
   
   SE
  
}

```




```{r}

SE_qPCR_raw <- make_raw_qpcr_SE(qpcr)
SE_qPCR_raw

```



### Aggregated `SummarizedExperiment` object

We create a `SummarizedExperiment` object with summarized values (aggregated across replicates) where each "sample" is a VIBRANT sample ID (including control samples) and each feature is a target (LBP taxa), with the following assays

  + `dilution`
  + `copies_per_swab_med` (the median `copies_per_swab` across replicates)
  + `copies_per_swab_mean` (the mean `copies_per_swab` across replicates)
  + `copies_per_swab_cv` (the coefficient of variation of `copies_per_swab` across replicates)

The `colData` contains the same columns as above (except for those that are replicate-specific)

The `rowData` contains the same columns as above,


```{r}

agg_qpcr_SE <- function(SE_qPCR_raw){
  
  filtered_qpcr <- 
    SE_qPCR_raw |> 
    dplyr::filter(
      !(qpcr_sample_type %in% c("Standard", "Negative control")),
      !is.na(uid) 
      ) 
    
  summarized_qpcr <- 
    filtered_qpcr |>
    as_tibble() |> 
    group_by(uid, target) |> 
    summarize(
      n_non_na = sum(!is.na(copies_per_swab)),
      dilution = mean(dilution, na.rm = TRUE),
      copies_per_swab_med = median(copies_per_swab, na.rm = TRUE),
      copies_per_swab_mean = mean(copies_per_swab, na.rm = TRUE),
      copies_per_swab_sd = sd(copies_per_swab, na.rm = TRUE),
      copies_per_swab_range = max(copies_per_swab, na.rm = TRUE) - min(copies_per_swab, na.rm = TRUE),
      .groups = "drop"
    ) |> 
    mutate(
      copies_per_swab_cv = ifelse(copies_per_swab_sd == 0, 0, copies_per_swab_sd / copies_per_swab_mean)
    ) 

  # COLDATA
  coldata <- 
    filtered_qpcr |> 
    colData() |> 
    as.data.frame() |> 
    as_tibble() |> 
    select(-qpcr_uid, -replicate_nb, -starts_with("pcr_plate"), -ext_lib_plate_nb) |> 
    distinct() |>  
    arrange(uid)
  
  coldata <-  
    coldata |> 
    dplyr::left_join(
      filtered_qpcr |> 
        colData() |> 
        as.data.frame() |> 
        as_tibble() |> 
        select(uid, contains("_plate_")) |> 
        group_by(uid) |> 
        summarize(
          pcr_plate_id = str_c(pcr_plate_id |> unique() |> sort(), collapse = ", "),
          pcr_plate_nb = str_c(pcr_plate_nb |> unique() |> sort(), collapse = ", "),
          ext_lib_plate_nb = str_c(ext_lib_plate_nb |> unique() |> sort(), collapse = ", "),
          .groups = "drop"
        ),
      by = join_by(uid)
    )
  
   coldata <-  
    coldata |> 
    as.data.frame() |> 
    mutate(rownames = uid) |> 
    column_to_rownames("rownames")
  
  # ROWDATA
   rowdata <-
     filtered_qpcr |> 
     rowData() |> 
     as.data.frame()
    
   SE <- SummarizedExperiment(
     assays = list(
       n_non_na = 
         summarized_qpcr |> 
         pivot_wider(id_cols = target, names_from = uid, values_from = n_non_na) |> 
         as.data.frame() |> 
         column_to_rownames("target") |> 
         as.matrix(),
        dilution = 
         summarized_qpcr |> 
         pivot_wider(id_cols = target, names_from = uid, values_from = dilution) |> 
         as.data.frame() |> 
         column_to_rownames("target") |> 
         as.matrix(),
       copies_per_swab_med = 
         summarized_qpcr |> 
         pivot_wider(id_cols = target, names_from = uid, values_from = copies_per_swab_med) |> 
         as.data.frame() |> 
         column_to_rownames("target") |> 
         as.matrix(),
       copies_per_swab_mean = 
         summarized_qpcr |> 
         pivot_wider(id_cols = target, names_from = uid, values_from = copies_per_swab_mean) |> 
         as.data.frame() |> 
         column_to_rownames("target") |> 
         as.matrix(),
       copies_per_swab_cv = 
         summarized_qpcr |> 
         pivot_wider(id_cols = target, names_from = uid, values_from = copies_per_swab_cv) |> 
         as.data.frame() |> 
         column_to_rownames("target") |> 
         as.matrix()
     ),
     colData = coldata,
     rowData = rowdata,
     metadata = list(
       description = "Aggregated qPCR data from the VIBRANT study",
       date = today(),
       assay_and_coldata_dictionary = SE_qPCR_raw@metadata$assay_and_coldata_dictionary
     )
   )
   
   SE
     
}

```


```{r}

SE_qPCR_agg <- agg_qpcr_SE(SE_qPCR_raw = SE_qPCR_raw)
SE_qPCR_agg

```


## Save `SummarizedExperiment` objects

We first check that the `SE_qPCR_agg` object is formatted as it should for its integration in the `MAE`.

```{r}

# We remove `pid` and `visit_code` from the colData to avoid conflict when merging with the metagenomics data.
colData(SE_qPCR_agg) <- colData(SE_qPCR_agg)[, -which(colnames(colData(SE_qPCR_agg)) %in% c("pid", "visit_code"))]
# We check that the `SE_qPCR_agg` object is formatted as it should
SE_qPCR_agg <- check_se(SE_qPCR_agg)

```


Save the `SE` objects to disk

```{r}

saveRDS(
  SE_qPCR_raw,
  str_c(
    get_01_output_dir(),
    "30_se_pcr_raw_", today() |> str_remove_all("-"), ".rds"
    )
  )


saveRDS(
  SE_qPCR_agg, 
  str_c(
    get_01_output_dir(),  
    "30_se_pcr_agg_", today() |> str_remove_all("-"), ".rds"
    )
  )

```




---
title: "VIBRANT clinical data - merging CRFs data into wide tables"
author: Laura Vermeren, Lara Wautier, Céline Bugli, Laura Symul
date: today
format: 
  html:
    code-fold: true
    toc: true
    toc-location: left
    theme: journal
    embed-resources: true
execute:
  cache: refresh # refresh true false
project:
  execute-dir: project
editor: 
  markdown: 
    wrap: 80
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

```{r}
#| warning: false
#| include: false
#| cache: false

library(tidyverse)
library(gt)
library(labelled)
library(gtsummary)
tmp <- fs::dir_map("R scripts/", source) 
tmp <- fs::dir_map("../VIBRANT-99-utils/R/", source)
rm(tmp)
theme_set(theme_bw())

```

The purpose of this document is to create:

- a `participant_crfs_merged`: a table with one row per `pid` containing harmonized data from CRFs that were supposed to be completed only once.

- `visits_crfs_merged` : a table with one row per `pid` and `visit_code` with harmonized data from CRFs that were meant to be completed at multiple visits.

# Load the CRF data processed in `01a-clinical-crf-data-cleaning.qmd`

```{r}

data_dir <- get_01_output_dir()

crf_clean_file <- data_dir |> fs::dir_ls() |> str_subset("01_crf_clean") |> sort(decreasing = TRUE) |> magrittr::extract(1)
load(crf_clean_file, verbose = TRUE)
crf_clean |> names()
rm(crf_clean_file)

```


# `participant_crfs_merged` table

List of the participant CRFs that are expected to be completed only once. 

```{r}

participants_crf_name <- 
  c("crf1", "crf101", "crf2", "crf102", 
    "crf5", 
    "crf6", "crf7", 
    "crf8", "crf9", "crf10", "crf11", "crf12", "crf13", "crf15", 
    "crf22", "crf23","crf24", "crf25", "crf28", 
    "crf43", "crf44","crf46"
    )
participants_crf_name
```

Some of those crf contained duplicate `pid` values. Some crf are filled at several visits and some are in log format. 

We need to correct them before creating the `participants_crfs_merged` table.

```{r}
map_df(
  participants_crf_name,
  function(participants_crf_name) {
    df <- crf_clean[[participants_crf_name]]
    
    if (!"pid" %in% names(df)) {
      return(tibble(crf = participants_crf_name, n_multi_pid = NA_integer_))
    }

    n <- 
      df |> 
      dplyr::count(pid) |> 
      dplyr::filter(n > 1) |> 
      nrow()

    tibble(crf = participants_crf_name, n_multi_pid = n)
  }
) |> gt()

```


## Correction of CRFs for participants with multiple entries

We create a function that, for each CRF in the participants table, compares the rows corresponding to duplicate `pid`s.  

If the rows are identical (*i.e.*, they have the same values for all columns except `visit_code` and `study_day`), only one row is kept.  

If the rows are not identical, they remain in the CRF and will be manually reviewed later.  

The `visit_code` and `study_day` variables are removed from these CRFs.


```{r}

process_crf_duplicates <- function(crf_clean, participants_crf_name) {

  participants_crf_filtered <- 
    crf_clean[names(crf_clean) %in% participants_crf_name]
  
  for (crf_name in participants_crf_name) {

    data <- crf_clean[[crf_name]]
    
    dup_pid <- 
      data |> 
      dplyr::count(pid) |> 
      dplyr::filter(n > 1) |> 
      pull(pid)
    
    if(!("study_day" %in% names(data))) {
      data <- 
        data |> 
        mutate(study_day = NA_integer_)
    }
    if(!("dfseq" %in% names(data))) {
      data <- 
        data |> 
        mutate(dfseq = NA_integer_)
    }

    if(!("visit_code" %in% names(data))) {
      data <- 
        data |> 
        mutate(visit_code = NA_integer_)
    }
    if(!("uid" %in% names(data))) {
      data <- 
        data |> 
        mutate(uid = NA_character_)
    }
    
    if (length(dup_pid) > 0) {
      data <- 
        data |> 
        distinct(across(-c(dfseq, study_day, visit_code, uid)), .keep_all = TRUE)
      
      participants_crf_filtered[[crf_name]] <- data
        
    } else {
      participants_crf_filtered[[crf_name]] <- data #|> select(-c(dfseq, study_day))
    }
    
}

  return(participants_crf_filtered)
}

participants_crf <- process_crf_duplicates(crf_clean, participants_crf_name)

```

A list of CRFs that still contain duplicate entries is displayed below. These will be examined manually.


```{r}

map_df(
  participants_crf_name,
  function(participants_crf_name) {
    df <- participants_crf[[participants_crf_name]]
    
    if (!"pid" %in% names(df)) {
      return(tibble(crf = participants_crf_name, n_multi_pid = NA_integer_))
    }

    n <- 
      df |> 
      dplyr::count(pid) |> 
      dplyr::filter(n > 1) |> 
      nrow()

    tibble(crf = participants_crf_name, n_multi_pid = n)
  }
) |> gt()

```

We review each of these CRFs and decide how to handle the duplicate entries.

### CRF1 

For this CRF, we keep the first observation for each participant since it's the only that contains data.

We also remove the participants from CAP (that do not have data fill in this CRF) and set the `site` variable to `"MGH"` for all participants.

```{r}

participants_crf[["crf1"]] <- 
  participants_crf[["crf1"]] |> 
  mutate(site = "MGH")

pid_temp <- 
  participants_crf[["crf1"]] |> 
  dplyr::count(pid) |> 
  dplyr::filter(n > 1) |> 
  pull(pid)

participants_crf[["crf1"]] |> 
  dplyr::filter(pid %in% pid_temp) |> 
  group_by(pid) |>
  gt(row_group_as_column = TRUE)

# Remove CAP participant : pid starts with 06820
participants_crf[["crf1"]] <-
  participants_crf[["crf1"]] |>
  filter(!str_starts(pid, "06820")) |>
  group_by(pid) |>
  arrange(dfseq) |> 
  slice_head(n = 1) |> 
  ungroup() |> 
  mutate(
    site = "MGH"
  )

```


### CRF101

For one specific case (`pid = 200156`), the `income_sources` variable is corrected manually.

Then, for each duplicated `pid`, the data are merged as follows:

- For all variables except `edu` and `income_sources`, we keep the **first recorded value**.  
- For `edu`, we keep the **highest education level**, using the order defined in `education_levels` (`Primary school` < `Secondary school` < `Tertiary education`).  
- For `income_sources`, we keep the **most complete response**, identified as the one containing the largest number of income sources (based on the number of commas).

Finally, the `site` variable is set to `"CAP"`

```{r}
# CRF101

pid_temp <- participants_crf[["crf101"]] |> 
  dplyr::count(pid) |> 
  dplyr::filter(n > 1) |> 
  pull(pid)

participants_crf[["crf101"]] |> 
  dplyr::filter(pid %in% pid_temp) |> 
  group_by(pid) |>
  gt(row_group_as_column = TRUE)

# 30 participants with double pid


education_levels <- c("Primary school", "Secondary school", "Tertiary education")

participants_crf[["crf101"]] <- 
  participants_crf[["crf101"]] |>
  mutate(
    income_sources = case_when(
      pid == "200156" ~ "employed_full_time, family_support, husband_provides, social_grants", 
      TRUE ~ income_sources
    )
  ) |> 
  group_by(pid) |>
  summarise(
    across(-c(edu, income_sources), ~ dplyr::first(.x)),
    edu = edu[which.max(match(edu, education_levels))],

    income_sources = income_sources[which.max(str_count(income_sources, ",") + 1)],
    
    .groups = "drop"
  ) |> 
  mutate(
    site = "CAP"
  )

rm(pid_temp, education_levels)

```
 
We combine the demographics data from `crf1` and `crf101` into a single table called `crf1_101`.

```{r}

participants_crf[["crf1_101"]] <- bind_rows(
  participants_crf[["crf1"]],
  participants_crf[["crf101"]]
)

#remove crf1 and 101 from the participant_crf
participants_crf[["crf1"]] <- NULL
participants_crf[["crf101"]] <- NULL

```


### CRF2
 
For participants with duplicate entries, if they ever reported being worried for any of the ‘worry’ variables, we retain the ‘Checked’ value (worst-case scenario).

The CRF also contains some participants from CAP, who do not have data in this CRF, we remove them.

```{r}
# CRF2 

pid_temp <- 
  participants_crf[["crf2"]] |> 
  dplyr::count(pid) |> 
  dplyr::filter(n > 1) |> 
  pull(pid)

participants_crf[["crf2"]] |> 
  dplyr::filter(pid %in% pid_temp) |> 
  group_by(pid) |>
  gt(row_group_as_column = TRUE)

# 6 participants with double pid

# if worry was "checked" and "uncheked" keep the worry "checked" 
worry_cols <- names(participants_crf[["crf2"]])[str_detect(names(participants_crf[["crf2"]]), "^worry_")]
other_cols <- setdiff(names(participants_crf[["crf2"]]), c("pid", worry_cols))

participants_crf[["crf2"]] <- 
  participants_crf[["crf2"]] |>
  filter(str_starts(pid, "06820")) |> # keep only MGH participants
  group_by(pid) |>
  summarise(
    across(all_of(other_cols), ~ dplyr::first(.x)),
    across(all_of(worry_cols), ~ if ("Checked" %in% .x) "Checked" else "Unchecked"),
    .groups = "drop"
  ) 

rm(pid_temp, worry_cols, other_cols)

```


### CRF102

The duplicate entries have incoherent response for the `monthly_gross_income` variable. We decide to keep the most recent visit.

These CRF also contains some participants from MGH, who do not have data in this CRF, we remove them.


```{r}
#crf102

pid_temp <- 
  participants_crf[["crf102"]] |> 
  dplyr::count(pid) |> 
  dplyr::filter(n > 1) |> 
  pull(pid)

participants_crf[["crf102"]] |> 
  dplyr::filter(pid %in% pid_temp) |> 
  group_by(pid) |>
  gt(row_group_as_column = TRUE)

participants_crf[["crf102"]] <-
  participants_crf[["crf102"]] |>
  filter(str_starts(pid, "06810")) |> # keep only CAP participants
  group_by(pid) |>
  arrange(-dfseq) |> 
  slice_head(n = 1) |> 
  ungroup()

rm(pid_temp)

```

We combine the socio demographics data from `crf2` and `crf102` into a single table called `crf2_102`.

```{r}

participants_crf[["crf2_102"]] <- bind_rows(
  participants_crf[["crf2"]],
  participants_crf[["crf102"]]
)

# Remove crf2 and 102 from the participant_crf
participants_crf[["crf2"]] <- NULL
participants_crf[["crf102"]] <- NULL

```


### CRF5

For each duplicated participant, the rows are merged while preserving all relevant information.  
The following rules are applied during summarization:

- **`no_pre_existing_condition`**:  
  If all entries are identical, the unique value is kept.  
  Otherwise, all unique values are concatenated with `" & "`.

- **`diagnosis_agg`**:  
  All reported diagnoses are concatenated with `" & "`.

- **`ongoing_enrollment`** and **`ongoing_at_exit`**:  
  If all entries are identical, the unique value is kept.  
  Otherwise, the function checks for inconsistencies between `ongoing_enrollment` (or `ongoing_at_exit`) and the corresponding `diagnosis`.  
  When differences are found, both the value and the related diagnosis are combined in the format  
  *`value (diagnosis)`*, and multiple such entries are concatenated with `" & "`.


```{r}

pid_temp <- 
  participants_crf[["crf5"]] |> 
  dplyr::count(pid) |> 
  dplyr::filter(n > 1) |> 
  pull(pid)

participants_crf[["crf5"]] |>
  dplyr::filter(pid %in% pid_temp) |> 
  group_by(pid) |>
  gt(row_group_as_column = TRUE)

participants_crf[["crf5"]] <- 
  participants_crf[["crf5"]]  |> 
  group_by(pid)  |> 
  summarise(
    no_pre_existing_condition = 
      if(length(unique(no_pre_existing_condition)) == 1) unique(no_pre_existing_condition) 
      else paste(unique(no_pre_existing_condition), collapse = " & "),
    
    diagnosis_agg = paste(diagnosis, collapse = " & "),
    
    ongoing_enrollment = {
      if(length(unique(ongoing_enrollment)) == 1) {
        unique(ongoing_enrollment)
      } else {
        paste(
          sapply(1:n(), function(i) {
            if(ongoing_enrollment[i] != ongoing_enrollment[1]) paste0(ongoing_enrollment[i], " (", diagnosis[i], ")") else ongoing_enrollment[i]
          }),
          collapse = " & "
        ) |> 
        unique()
      }
    },
    ongoing_at_exit = 
      if(length(unique(ongoing_at_exit)) == 1) unique(ongoing_at_exit) 
    else {
      paste(
        sapply(1:n(), function(i) {
          if(ongoing_at_exit[i] != ongoing_at_exit[1]) paste0(ongoing_at_exit[i], " (", diagnosis[i], ")") else ongoing_at_exit[i]
        }),
        collapse = " & "
      )  |> 
      unique()
    }
  )


```

### CRF6

We keep the values of the most recent visit.

```{r}
# crf6


pid_temp <- 
  participants_crf[["crf6"]] |> 
  dplyr::count(pid) |> 
  dplyr::filter(n > 1) |> 
  pull(pid)
pid_temp

participants_crf[["crf6"]] |> 
  dplyr::filter(pid %in% pid_temp) |> 
  group_by(pid) |>
  gt(row_group_as_column = TRUE)

#78 participants with double pid

participants_crf[["crf6"]] <- 
  participants_crf[["crf6"]] |>
  group_by(pid) |>
  arrange(-study_day) |> 
  slice_head(n = 1) |> 
  ungroup() |> 
  dplyr::rename(
    age_at_consent = age
  )

rm(pid_temp)

```


### CRF7

We keep the values of the most recent visit.

```{r}
# CRF7

pid_temp <- participants_crf[["crf7"]] |> 
  dplyr::count(pid) |> 
  dplyr::filter(n > 1) |> 
  pull(pid)

participants_crf[["crf7"]] |>
  dplyr::filter(pid %in% pid_temp) |> 
  group_by(pid) |>
  gt(row_group_as_column = TRUE)


participants_crf[["crf7"]] <-
  participants_crf[["crf7"]] |>
  group_by(pid) |>
  arrange(-study_day) |> 
  slice_head(n = 1) |> 
  ungroup()

rm(pid_temp)

```


### CRF8

We keep the values of the most recent visit.

```{r}

pid_temp <- participants_crf[["crf8"]] |> 
  dplyr::count(pid) |> 
  dplyr::filter(n > 1) |> 
  pull(pid)
pid_temp

participants_crf[["crf8"]] |> 
  dplyr::filter(pid %in% pid_temp) |> 
  group_by(pid) |>
  gt(row_group_as_column = TRUE)

participants_crf[["crf8"]] <-
  participants_crf[["crf8"]] |>
  group_by(pid) |>
  arrange(-study_day) |> 
  slice_head(n = 1) |> 
  ungroup()

rm(pid_temp)

```



### CRF9

Only one participant is duplicated. We decide to keep the most recent observation.

```{r}

pid_temp <- 
  participants_crf[["crf9"]] |> 
  dplyr::count(pid) |> 
  dplyr::filter(n > 1) |> 
  pull(pid)

pid_temp

participants_crf[["crf9"]] |> 
  dplyr::filter(pid %in% pid_temp) |> 
  group_by(pid) |>
  gt(row_group_as_column = TRUE)


participants_crf[["crf9"]] <- 
  participants_crf[["crf9"]] |>
  group_by(pid) |>
  arrange(-study_day) |>
  slice_head(n = 1) |>
  ungroup()

rm(pid_temp)

```


### CRF10

We keep the most recent visit.  

```{r}

pid_temp <- 
  participants_crf[["crf10"]] |> 
  dplyr::count(pid) |> 
  dplyr::filter(n > 1) |> 
  pull(pid)
pid_temp

participants_crf[["crf10"]] |> 
  dplyr::filter(pid %in% pid_temp) |> 
  group_by(pid) |>
  gt(row_group_as_column = TRUE)

participants_crf[["crf10"]] <- 
  participants_crf[["crf10"]]|> 
  group_by(pid) |>
  arrange(-study_day) |>
  slice_head(n = 1) |>
  ungroup()

rm(pid_temp)
```



### CRF11

We keep the most recent visit.

```{r}


pid_temp <- 
  participants_crf[["crf11"]] |> 
  dplyr::count(pid) |> 
  dplyr::filter(n > 1) |> 
  pull(pid)
pid_temp

participants_crf[["crf11"]] |> 
  dplyr::filter(pid %in% pid_temp) |> 
  group_by(pid) |>
  gt(row_group_as_column = TRUE)


participants_crf[["crf11"]] <-
  participants_crf[["crf11"]] |>
  group_by(pid) |>
  arrange(-study_day) |>
  slice_head(n = 1) |>
  ungroup()

rm(pid_temp)

```



### CRF12

We keep the most recent visit. 

```{r}

pid_temp <- 
  participants_crf[["crf12"]] |> 
  dplyr::count(pid) |> 
  dplyr::filter(n > 1) |> 
  pull(pid)
pid_temp

participants_crf[["crf12"]] |> 
  dplyr::filter(pid %in% pid_temp) |> 
  group_by(pid) |>
  gt(row_group_as_column = TRUE)


participants_crf[["crf12"]] <- 
  participants_crf[["crf12"]] |>
  group_by(pid) |>
  arrange(-dfseq) |> 
  slice_head(n = 1) |> 
  ungroup()

rm(pid_temp)

```

### CRF15

Only one participant is duplicated. We combine the response for the two variable :
- `pap_smear_results` we keep *Negative for intraepithelial lesion or cancer (malignancy)*
- `blood_type` we keep *AB positive (AB+)*

```{r}

pid_temp <- participants_crf[["crf15"]] |> 
  dplyr::count(pid) |> 
  dplyr::filter(n > 1) |> 
  pull(pid)
pid_temp

participants_crf[["crf15"]] |> 
  dplyr::filter(pid %in% pid_temp) |> 
  group_by(pid) |>
  gt(row_group_as_column = TRUE)


participants_crf[["crf15"]] <-
  participants_crf[["crf15"]] |> 
  mutate(
    pap_smear_results = case_when(
      pid == 200085 ~ "Negative for intraepithelial lesion or cancer (malignancy)",
      TRUE ~ pap_smear_results
    ),
    blood_type = case_when(
      pid == 200085 ~ "AB positive (AB+)",
      TRUE ~ blood_type
    )
  ) |> 
  group_by(pid) |> 
  arrange(-dfseq) |>
  slice_head(n = 1) |>
  ungroup()
  

```



### CRF22 (Metrodanizole exposure)

Data are used to create the exposure table. 

Some participants came twice, either because they were in the overlap arm, or because they had not completed treatment at the first visit.

We keep the second observation for these participants.

We rename the variable `prescription_container` to `prescription_container_metronidazole`, `tablets_remain` to `tablets_remain_metronidazole` to avoid conflict with the data from CRF23 (study product exposure).

```{r}


pid_temp <- 
  participants_crf[["crf22"]] |> 
  dplyr::count(pid) |> 
  dplyr::filter(n > 1) |> 
  pull(pid)
pid_temp

participants_crf[["crf22"]] |> 
  dplyr::filter(pid %in% pid_temp) |> 
  group_by(pid) |>
  gt(row_group_as_column = TRUE)


participants_crf[["crf22"]] <-
  participants_crf[["crf22"]] |>
  group_by(pid) |>
  arrange(-study_day) |>
  slice_head(n = 1) |>
  ungroup() |> 
  dplyr::rename(
    prescription_container_metronidazole = prescription_container, 
    tablets_remain_metronidazole = tablets_remain,
    #comments_metronidazole = comments
  )
  
```


### CRF23 (product exposure)

Data are used to create the exposure table. 
Some participants came twice because they were in the overlap arm or because they don't finished the treatment at the first visit.

So we keep the second observation for these participants.

```{r}

pid_temp <- 
  participants_crf[["crf23"]] |> 
  dplyr::count(pid) |> 
  dplyr::filter(n > 1) |> 
  pull(pid)
pid_temp

participants_crf[["crf23"]] |> 
  dplyr::filter(pid %in% pid_temp) |> 
  group_by(pid) |>
  gt(row_group_as_column = TRUE)


participants_crf[["crf23"]] <-
  participants_crf[["crf23"]] |>
  group_by(pid) |>
  arrange(-study_day) |>
  slice_head(n = 1) |>
  ungroup() |> 
  dplyr::rename(
    prescription_container_study_product = prescription_container, 
    tablets_remain_study_product = tablets_remain,
    #comments_study_product = comments
  )

```



### CRF24

We keep the most recent visit.

```{r}


pid_temp <- 
  participants_crf[["crf24"]] |> 
  dplyr::count(pid) |> 
  dplyr::filter(n > 1) |> 
  pull(pid)
pid_temp

participants_crf[["crf24"]] |> 
  dplyr::filter(pid %in% pid_temp) |> 
  group_by(pid) |>
  gt(row_group_as_column = TRUE)


participants_crf[["crf24"]] <-
  participants_crf[["crf24"]] |>
  group_by(pid) |>
  arrange(-study_day) |> 
  slice_head(n = 1) |> 
  ungroup()

```


### CRF25

We keep the most recent visit.

```{r}


pid_temp <- 
  participants_crf[["crf25"]] |> 
  dplyr::count(pid) |> 
  dplyr::filter(n > 1) |> 
  pull(pid)

participants_crf[["crf25"]] |>
  dplyr::filter(pid %in% pid_temp) |> 
  group_by(pid) |>
  gt(row_group_as_column = TRUE)


participants_crf[["crf25"]] <-
  participants_crf[["crf25"]] |>
  group_by(pid) |>
  arrange(-study_day) |> 
  slice_head(n = 1) |> 
  ungroup()


```

### CRF28

We keep the most recent visit.

```{r}

pid_temp <- 
  participants_crf[["crf28"]] |> 
  dplyr::count(pid) |> 
  dplyr::filter(n > 1) |> 
  pull(pid)
pid_temp

participants_crf[["crf28"]] |> 
  dplyr::filter(pid %in% pid_temp) |> 
  group_by(pid) |>
  gt(row_group_as_column = TRUE)


participants_crf[["crf28"]] <-
  participants_crf[["crf28"]] |>
  group_by(pid) |>
  arrange(-study_day) |> 
  slice_head(n = 1) |> 
  ungroup()

```

### CRF46

We keep the first observation for these participants since the second observation is not complete.

```{r}

pid_temp <- 
  participants_crf[["crf46"]] |> 
  dplyr::count(pid) |> 
  dplyr::filter(n > 1) |> 
  pull(pid)

participants_crf[["crf46"]] |>
  dplyr::filter(pid %in% pid_temp) |> 
  group_by(pid) |>
  gt(row_group_as_column = TRUE)


participants_crf[["crf46"]] <-
  participants_crf[["crf46"]] |>
  group_by(pid) |>
  arrange(dfseq) |> 
  slice_head(n = 1) |> 
  ungroup()


```



## Making the `participant_crfs_merged` table

We check that the number of repeated `pid` is null. 

```{r}
table_p <- 
  map_df(
  names(participants_crf),
  function(participants_crf_name) {
    df <- participants_crf[[participants_crf_name]]
    
    if (!"pid" %in% names(df)) {
      return(tibble(crf = participants_crf_name, n_multi_pid = NA_integer_))
    }

    n <- 
      df |> 
      dplyr::count(pid) |> 
      dplyr::filter(n > 1) |> 
      nrow()

    tibble(crf = participants_crf_name, n_multi_pid = n)
  }
)

table_p |> gt()

# Select crf with 0 multi pids
participants_crf_name <- 
  table_p |> 
  filter(n_multi_pid == 0) |> 
  pull(crf)

```

We create the `participant_crfs_merged` table by merging all the participant CRFs.

```{r}

participant_crfs_merged <-
  participants_crf[names(participants_crf) %in% participants_crf_name] |> 
  map(
    function(df) {
      if ("dfseq" %in% names(df)) {df |> select(-any_of(c("uid", "visit_code","dfseq", "study_day", "vdate_fixed")))
      } else {df}
    }
  ) |>
  purrr::reduce(full_join, by = join_by(pid))
  

# participant_crfs_merged |> colnames() |> str_detect("\\.y") |> sum()
```


# `visits_crfs_merged` table

Visit CRFs refer to those CRFs not present in the participants CRF list.

We check that each of these CRFs includes both the `study_day` and `visit_code` variables. Any CRF that does not meet this requirement is excluded from the visit CRF list.
We also remove CRF29 (Adverse event) and CRF34 (protocol deviation) because they does not contain visit_code.

```{r}

visits_crf_name <- 
  setdiff(names(crf_clean[!names(crf_clean) %in% c("crf1", "crf101", "crf2", "crf102")]),
          participants_crf_name) |> 
  setdiff("crf27_long")

```

CRF with no `study_day`

```{r}
#crf in visits_crf name but with no study_day variable
no_studyday <- crf_clean[names(crf_clean) %in% visits_crf_name] |>
  keep(~ !"study_day" %in% names(.x)) |>
  names()
no_studyday
```


CRFs with no `visit_code`

```{r}
#crf in visits_crf name but with no dfseq variable
no_visit_code<- crf_clean[names(crf_clean) %in% visits_crf_name] |>
  keep(~ !"visit_code" %in% names(.x)) |>
  names()
no_visit_code
```

CRFs used to create `visits_crfs_merges`table: 

```{r}

visits_crf_name <- 
  setdiff(visits_crf_name, no_visit_code) |> 
  setdiff("crf29") |> 
  setdiff("crf34")

visits_crf_name

```

We now check that each CRF contains one row per participant and visit (i.e., per `uid`).  

```{r}

map_df(
  visits_crf_name,
  function(visits_crf_name) {
    df <- crf_clean[[visits_crf_name]]
    
    if (!"uid" %in% names(df)) {
      return(tibble(crf = visits_crf_name, n_multi_uid = NA_integer_))
    }

    n <- 
      df |> 
      dplyr::count(uid) |> 
      dplyr::filter(n > 1) |> 
      nrow()

    tibble(crf = visits_crf_name, n_multi_uid = n)
  }
) |> gt()

```


In CRF14, one `uid` (=068100002_0000) appears four times : two times with the same data and two times with incomplete data.

We keep one of the complete data and remove the two incomplete data.

```{r}
#crf14
uid_tmp <- 
  crf_clean[["crf14"]] |>
  dplyr::count(uid) |>
  dplyr::filter(n > 1) |>
  pull(uid)

crf_clean[["crf14"]] |>
  dplyr::filter(uid %in% uid_tmp) |>
  group_by(uid) |>
  gt(row_group_as_column = TRUE)

crf_clean[["crf14"]] <- 
  crf_clean[["crf14"]] |>
  filter(!(uid=="068100002_0000" & nugent_done == "Not done")) |> 
  distinct()
  
```

We join the CRFs to create the `visits_crfs_merged` table.

```{r}

# Some columns have the same name in different crf, we rename them by adding the crf name as suffix

crf_list_renamed <-
  crf_clean |>
  imap(function(df, name) {
    double_cols <- c("vaginal_discharge", "vaginal_bleeding", "put_in_vagina_type", "sex_past_24hours", "page")
    names(df)[names(df) %in% double_cols] <- paste0(names(df)[names(df) %in% double_cols], ".", name)
    df
  })


visits_crfs_merged <-
  crf_list_renamed[setdiff(visits_crf_name, no_studyday)] |> 
  map(
    function(df) {
      df |> select(-any_of(c("uid", "vdate_fixed"))) #"uid",
    }
  ) |>
  purrr::reduce(full_join, by = join_by(pid, visit_code, dfseq, study_day))
  
# Then add crf with no study_day

visits_crfs_merged <- 
  visits_crfs_merged |> 
  full_join(
    crf_list_renamed[setdiff(no_studyday, no_visit_code)] |> 
      map(
        function(df) {
          df |> select(-any_of(c("uid")))
        }
      ) |>
      purrr::reduce(full_join, by = join_by(pid, visit_code, dfseq)),
    by = join_by(pid, visit_code, dfseq)
  )

```

We remove data for which `hiv_result` is "missing" and for wich we have no other data. 

```{r}
visits_crfs_merged <-
  visits_crfs_merged |> 
  filter(!(hiv_results == "Missing"  & nugent_done == "Missing" &
             if_all(-c(pid, visit_code, dfseq, hiv_results, nugent_done), is.na))) |> 
  distinct()
```

```{r}
visits_crfs_merged |> 
  mutate(uid = str_c(pid, "_", visit_code)) |> 
  dplyr::count(uid) |> 
  dplyr::filter(n > 1)
```



# Exports


```{r}

dir <- get_01_output_dir()

save(participant_crfs_merged, file = str_c(dir, "01_participant_crfs_merged_", today() |> str_replace_all("-",""), ".Rdata"))
save(visits_crfs_merged, file = str_c(dir, "01_visits_crfs_merged_", today() |> str_replace_all("-",""), ".Rdata"))

```

